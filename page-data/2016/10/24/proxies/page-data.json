{"componentChunkName":"component---src-templates-slide-tsx","path":"/2016/10/24/proxies","webpackCompilationHash":"88062f546259d5d495e1","result":{"data":{"markdownRemark":{"internal":{"content":"\n# Proxies en ES6\n\n---\n\n## Agenda\n\n<small>\n  Terminología  \n  Desarrollo  \n  Casos de uso  \n  Ejercitación  \n  Desarrollo  \n  Casos de uso  \n  Ejercitación  \n</small>\n\n---\n\n## Terminología\n\n---\n\n¿Que es un proxy?  \nOrigen: _prokecye_  \n \"agency of one who acts instead of another\"  \nEn español significa _apoderado_  \n _adj._ Dicho de una persona: Que tiene poderes de otra para representarla y proceder en su nombre\n\n???\nEjemplo, firmar un poder para hacer un trámite\n\n---\n\n¿Que es un protocolo?  \nUn _protocolo_ es un conjunto de normas. Esto podria verse como un conjunto interfaces con reglas para usarlas, y ECMAScript define un protocolo para manejar objetos. Este protocolo opera a nivel Meta.\n\n???\nLa definición no es la misma que suele utilizarse de protocolos para interfaces de otros lenguajes porque también incluye reglas.\n\n---\n\n_Metaprogramming_  \nEn la programación hay niveles base y meta. El nivel base procesa el input del usuario, mientras que el meta procesa al base.\n\n???\nPueden incluso ser dos lenguajes distintos.\nEn es como los closures, los usamos sin saber.\nHay unos que usamos constantemente: Object.\\*\n\n---\n\n_Meta Object Protocol_ es como se lo llama al protocolo de manejo de objetos de ECMAScript. Como particularidad, son internos (no son accesibles desde JS). Los engines pueden usarlos o no.\n\n---\n\n- Los metodos de un objeto del MOP llaman operaciones del engine, algunas que llaman a otras como [[Get]], que se llaman _operaciones derivadas_ y las que son independientes, que se llaman _operaciones fundamentales_.\n\n???\nEjemplo [[Get]] usa getOwnProperty, getPrototypeOf y Call\n\n---\n\n_Tipos de metaprogramming_\n\n- Introspection: permite sólo leer la estructura\n- Self-modification: permite modificar la estructura\n- Intercession: redefine la semantica de algunas operaciones\n\n???\nEjemplos Object.keys, moveProperty, proxy respectivamente\n\n---\n\n_Elementos del proxy_\n\n- target: es el fallback del handler, el representado\n  [[ProxyTarget]]\n- handler: es quien, en caso de definir el método indicado, intercepta la llamada, el representante\n  [[ProxyHandler]]\n- proxy: el que compone ambos y delega a uno u otro\n\n```\nconst proxy: new Proxy(target, handler); // OK\nvar p = Proxy(target, handler); // TypeError: calling a builtin Proxy constructor without new is forbidden\n```\n\n???\nEl método del handler se llama trap.  \nEs decir que el proxy \"wrappea\" al target.\n\n---\n\n```\nclass MyHandler {\n  get(target, key, receiver) {\n    return Reflect[key];\n  }\n}\n```\n\n???\nReflect no se puede instanciar, tiene los mismos metodos que el handler, es como Math, todo estatico\nPor ejemplo Reflect.apply es menos verboso que Function.prototype.apply\nAlgunas veces nos da información adicional como Reflect.set -> [boolean]\n\n---\n\n_¿Que operaciones pueden ser interceptadas?_  \nEsto es selectivo, no se puede interceptar todo o solo las fundamentales como podria suponerse.  \nEsto es por dos razones\n\n- porque una operacion estable corre el riesgo de que un proxy la haga inestable\n- porque tener mucho codigo custom intercalado haria el programa muy dificil de entender y debuggear\n\n???\nejemplo el === que no puede ser trapeada.\nEstable: sin side effects, que produce siempre el mismo resultado ante los mismos argumentos  \nSe podría pensar como que con interceptar sólo operaciones fundamentales, pero esto no es tan útil ya que no inlcuiría get por ejemplo.\nVer codigo de api client.\n\n---\n\n_Prototype chain_  \nLos engines en su comportamiento habitual, al subir por el chain, van a disparar las traps que encuentren.  \nSin embargo, hay ciertas operaciones que suben por el prototype chain si no encuentran la property en el handler como get, set y has, las demas no alteran el prototype chain.\n\n???\nVer codigo y test de ghost.\nInstanceof \"lies\"\n\n---\n\n_Básicas_\n\n```\ndefineProperty(target, propKey, propDesc) // → boolean  (fundamental)\n  // trigger: Object.defineProperty(proxy, propKey, propDesc)\ndeleteProperty(target, propKey) // → boolean  (fundamental)\n  // trigger: delete proxy[propKey], delete proxy.foo\nget(target, propKey, receiver) // → any\n  // trigger: receiver[propKey]\n  // trigger: receiver.foo\n```\n\n---\n\n_Casos de uso_\n\n- API Client\n- Tracing / Logging\n- Trap undefined property access\n- Type check\n\n???\nSeñalar el tracing puede implementarse cambiando el objeto.\nType check example: properties que son \"fieles\" a su tipo incial.\nIr viendo ejemplos de api client, logging y lock\n\n---\n\n_Preguntas_\n\n---\n\n_Practica 1_  \nHacer \"trap undefined\"  \n\"Objeto que tira excepcion cuando se accede a una propiedad undefined\"\n(30 minutos)\n\n???\nDebe tirar un ReferenceError si no esta. Debe devolver el valor si esta.\nProbar nested with lock.\n\n---\n\n_Compatibilidad_\n\n- Solo FF, CH, Edge, Opera, Safari 10, Node 6\n\n???\nNo hay polyfill.\n\n---\n\n_Tipos de proxy_\n\n- Wrappers (solo control) o Virtual Objects (agregan comporamiento)\n\n???\nWrappers se refiere a esos casos en los que intercepta para controlar el acceso al target, mientras que virtual se refiere a cuando agregan un comportamiento y el virtual object no importa (ejemplo, property check y RMI respectivamente)\n\n---\n\n_Propiedades del proxy_\n\n- Transparencia virtual: no podemos saber si un objeto es un proxy\n- Encapsulamiento: no podemos acceder al handler desde el proxy\n\n???\nWrappers se refiere a esos casos en los que intercepta para controlar el acceso al target, mientras que virtual se refiere a cuando agregan un comportamiento y el virtual object no importa (ejemplo, property check y RMI respectivamente)\n\n---\n\n_Mas casos de uso_\n\n- DOM\n- Indices negativos de array\n- Data binding (polemico)\n- Profiling\n- RMI\n\nNote:\nDOM: usualmente está implementado entre C++ y JS, y el context switch es costoso, lo que nos lleva a querer hacer el dom en js puro, pero hay cosas que no son tan simples de implementar, y ello fue una importante razon para hacer los proxies en JS (dom mas eficiente) y ademas que nos permite emular el browser (jsdom).\n\nIndices negativos como en algunos lenguajes.\nMencionar Object.observe (ES7) creado para binding por la pobre performance de los proxy, aunque abandonado por react.\nObject.observe no es necesario con la inmutabilidad, tratar browser como remote rendering, no storage y query\n(undo, state). Se dice que es lo que queremos, no lo que necesitamos (Stateful dom).\nProfiling para medir tiempo.\nRMI permite por ejemplo db access directo.\n\n---\n\n_Invariants_  \nSi el target es no extensible y no configurable, lo invariante es forzado por el engine.\n\n???\nno extensible protege objetos, non configurability protege properties.\nCon los proxy se podría violar la invariabilidad, pero el engine lo prohibe chequeando los parametros y los resultados de los handlers, preventExtension, true y luego false, e igual para isExtensible y getOwnPropertyDescriptor\n\n---\n\n_Practica 2_  \nMejorar api client  \n(30 minutos)\n\n???\nelegir algunos de los TODO\n\n---\n\n_Avanzadas 1_\n\n```\ngetOwnPropertyDescriptor(target, propKey) // → PropDesc|Undefined  (fundamental)\n  // tby: Object.getOwnPropertyDescriptor(proxy, propKey)\ngetPrototypeOf(target) // → Object|Null  (fundamental)\n  // tby: Object.getPrototypeOf(proxy)\nhas(target, propKey) // → boolean\n  // tby: propKey in proxy\n```\n\n---\n\n_Avanzadas 2_\n\n```\nisExtensible(target) // → boolean  (fundamental)\n  // tby: Object.isExtensible(proxy)\nownKeys(target) // → Array<PropertyKey>  (fundamental)\n  // tby: Object.getOwnPropertyPropertyNames(proxy) (only uses string-valued keys)\n  // tby: Object.getOwnPropertyPropertySymbols(proxy) (only uses symbol-valued keys)\n  // tby: Object.keys(proxy) (only uses enumerable string-valued keys;\n  // enumerability is checked via Object.getOwnPropertyDescriptor)\n```\n\n---\n\n_Avanzadas 3_\n\n```\npreventExtensions(target) // → boolean  (fundamental)\n  // tby: Object.preventExtensions(proxy)\nset(target, propKey, value, receiver) // → boolean\n  // tby: receiver[propKey] = value\n  // tby: receiver.foo = value // propKey = 'foo'\nsetPrototypeOf(target, proto) // → boolean  (fundamental)\n  // tby: Object.setPrototypeOf(proxy, proto)\n```\n\n---\n\n_Para funciones_\n\n```\napply(target, thisArgument, argumentsList) // → any\n  // tby: proxy.apply(thisArgument, argumentsList) (fundamental)\n  // tby: proxy.call(thisArgument, ...argumentsList)\n  // tby: proxy(...argumentsList)\nconstruct(target, argumentsList) // → Object\n  // tby: new proxy(..argumentsList)\n```\n\n---\n\n_Conclusion_\n\n- Performance\n- Debug\n- Casos de uso\n- Complejidad\n- Compatibilidad\n\nNote:\nPerformance: Conviene medir la performance en cada caso, evaluar que tan critica es la performance en nuestra app y tomar una decision.\nA mas código interceptado, menor performance, mayor dificultad de entender el codigo y de debug.\nRiesgo: podemos \"romper\" comportamientos, hacerlo inconsistente\nCasos de uso:\n\n---\n\n_Preguntas / Discusion / Ideas_\n\n---\n\nGracias!\n"},"frontmatter":{"date":"October 24, 2016","url":"/2016/10/24/proxies","title":"proxies","author":"nico","categories":null,"tags":null,"type":"remark-slide"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}