<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on nicosommi</title>
    <link>http://nicosommi.github.com/categories/technology/</link>
    <description>Recent content in Technology on nicosommi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-AR</language>
    <lastBuildDate>Wed, 30 Mar 2016 16:47:00 +0000</lastBuildDate>
    <atom:link href="http://nicosommi.github.com/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A common pitfall when using “global” (not really) CLI’s in your node.js project (like gulp)</title>
      <link>http://nicosommi.github.com/index.php/2016/03/30/a-good-way-to-use-global-not-really-clis-in-your-node-js-project-like-gulp/</link>
      <pubDate>Wed, 30 Mar 2016 16:47:00 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2016/03/30/a-good-way-to-use-global-not-really-clis-in-your-node-js-project-like-gulp/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&amp;#8220;Little things can make a big difference.&amp;#8221;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“Little things can make a big difference.” I’m sure you heard that phrase a lot. Well there are cases in which that is true. And this is, at my opinion, one of those cases. Some people know about this detail I&amp;#8217;m going to talk about, but most people don’t.&lt;/p&gt;

&lt;p&gt;Why? Almost everyone, including me until recently, when they decide to use a tool, like gulp, on one of their node.js projects, they creates a gulp file on the project root with some tasks like “test” on it for example, and then run something like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;gulp test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Right?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Well. I understand you if that&amp;#8217;s your case, because they tell you to do so in the official documentation. I did the same some time ago. But, in most cases, that&amp;#8217;s a bad thing to do. I will say that you should stop doing that ASAP.&lt;/em&gt; Not the gulpfile, that&amp;#8217;s ok, but I have what I think it is a solid set of arguments against using gulp as a top level task runner (I mean installed globally). &lt;em&gt;Let me explain you why.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Firstly, I want my node.js project to be cloned and executed right away. Period. &lt;em&gt;I do not want the container / user / developer / anybody to install something globally on their environments&lt;/em&gt; besides of the natural requirements for that technology. Because &lt;em&gt;is just unrelated&lt;/em&gt; to my node.js project environment. It&amp;#8217;s not a global dependency, it is a local dependency&lt;strong&gt;.&lt;/strong&gt; The flow should be something more like: git clone, npm install, npm test. &lt;em&gt;And that&amp;#8217;s it.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Let&amp;#8217;s imagine this situation for a minute.&lt;/em&gt; I&amp;#8217;m making public modules relying on the global gulp. On the other hand, you&amp;#8217;re a developer and you&amp;#8217;re new to node.js&amp;#8230; then you start with some project and you decide to clone one of my modules. Now, suddenly, if you want to run the test or maybe do some other task like contributing to my project, you need to install some global tool called, in this example, gulp. So now you need to read lot&amp;#8217;s of docs to know what it is and how it works. &lt;em&gt;All right, I would say that coupling gulp learning curve to my node.js modules is not intuitive and it&amp;#8217;s also unfair for those developers who don&amp;#8217;t know about our custom tool preference or they just don&amp;#8217;t want to learn it. So by doing this, you&amp;#8217;re not just creating a dependency for your projects in your environments but also for the users/potential contributors of your module if it&amp;#8217;s a public module, or the developers in your team if it&amp;#8217;s not.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;I would say that coupling gulp learning curve to my node.js modules is not intuitive and it&amp;#8217;s also unfair for those developers who don&amp;#8217;t know about our custom tool preference or they just don&amp;#8217;t want to learn it. So by doing this, you&amp;#8217;re not just creating a dependency for your projects in your environments but also for the users&lt;em&gt;/potential contributors&lt;/em&gt; of your module if it&amp;#8217;s a public module, or the developers in your team if it&amp;#8217;s not.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wait, this is not just some hedonistic crap. And it&amp;#8217;s not just me believing it&amp;#8217;s better. That thing can hurt your open source strategy and it can make you lose time with your team.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And there are even more real conflicts with this&amp;#8230; specifically with module versions.&lt;/em&gt; If you don&amp;#8217;t believe me, just start playing with babel versions 5, 6 along with gulp versions 2 and 3 in two or three different projects, and you will face a lot of problems. Because you&amp;#8217;re sharing dependency versions among projects by using a global CLI. Gulp (like almost any other popular CLI in node.js) is not really a global CLI, is a dependency of each one of your projects. So on each case you really need to ask to yourself &amp;#8220;is this CLI a real global dependency or is related to my projects individually?&amp;#8221;. Because if you decide this wrong, this may force you to update your old projects after you update one, or switch constantly global CLI versions, and this task can be very annoying, &lt;strong&gt;&lt;em&gt;making you lose time and money&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You may think, well anyway I just have a few projects and if I refresh one I can just refresh all of them. Well if you grow you will have troubles this is a side effect on the team plan. It&amp;#8217;s creating unexpected efforts. And it may be not so easy to figure out which versions are failing.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;_**Gulp (like almost any other popular CLI in node.js) is not really a global CLI, is a dependency of each one of your projects. So on each case you really need to ask to yourself &amp;#8220;is this CLI a real global dependency or is related to my projects individually?&amp;#8221; Because if you decide this wrong, this may force you to update your old projects after you update one, or switch constantly global CLI versions, and this task can be very annoying, &lt;strong&gt;&lt;em&gt;making you lose time and money&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;**_&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Even if gulp get a really amazing development process in which they fully stick to backwards compatibility, this is not a recommended practice at all, mainly because you are creating a node.js project, not a gulp project. And it does not depend on one framework as I told you with the babel/gulp letal combination. &lt;em&gt;I remember that day. We literally had to refresh all our modules because they suddenly started to fail in the continuous integration server when the environment changed.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;I remember that day. We literally had to refresh all our modules because they suddenly started to fail in the continuous integration server when the environment changed.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Introduction to the &amp;#8220;trivial&amp;#8221; solution&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Node.js comes with the npm binary built in&lt;/em&gt;. Npm supports, via package.json, running scripts in different stages or phases and also custom scripts. Also, some packages like gulp have a binary link for which &lt;em&gt;npm creates a symbolic link automatically on a project scoped bin folder and npm run includes those links in the PATH automatically for the scripts in the package.json&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;npm creates a symbolic link automatically on a project scoped bin folder and npm run includes those links in the PATH automatically for the scripts in the package.json.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You can see a reference here &lt;a href=&#34;https://docs.npmjs.com/cli/run-script&#34;&gt;https://docs.npmjs.com/cli/run-script&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So the point is to use the local gulp binary link in the package.json as a shortcut for executing your internal gulp tasks.&lt;/em&gt; And, luckily, that is transparent to us.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;So the point is to use the local gulp binary link in the package.json as a shortcut for executing your internal gulp tasks&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;How to do this?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Well basically, let&amp;#8217;s say you want to replace your &lt;em&gt;gulp test&lt;/em&gt; command so you don&amp;#8217;t need a global gulp&amp;#8230; well ok, then simply add this to your scripts section of your package.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;...(content on your package.json)...
&#34;scripts&#34;: {
&#34;test&#34;: &#34;gulp test&#34;
}
...(more content on your package.json)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;And that&amp;#8217;s it!&lt;/strong&gt; With that line now you just need a node js regular environment with nothing installed globally on it, like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;npm test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trivial? Well not so fast. This is the small detail. If you read the npm documentation, maybe you are doing this already. But according to my experience and what I see out there, some people do this but they don&amp;#8217;t know what happens behind the scenes and most people just use the global gulp&lt;em&gt;. This npm test command is not executing the global gulp. The better way to experiment this is just uninstalling the global gulp. And please do that ASAP!&lt;/em&gt; &lt;em&gt;You just need to install gulp (or the CLI you want to make local) locally&lt;/em&gt; in your project before you execute the script through &lt;strong&gt;npm run&lt;/strong&gt;&amp;#8230; remember that. So this is picking the link from the PATH that points to the node_modules version of gulp of your project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;npm uninstall -g gulp
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;**&lt;em&gt;This npm test command is not executing the global gulp.&lt;/em&gt; The better way to experiment this is just uninstalling the global gulp. And please do that ASAP! You just need to install gulp (or the CLI you want to make local) locally&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;**Sugar for complex cases&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;p&gt;As I said earlier, you can use custom scripts (meaning any name you want) on the scripts element on your package.json. If that&amp;#8217;s your case, after you added it on your package.json, you need can run that custom npm script with this command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javacript&#34;&gt;npm run gulp yourcustomtask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here, an elegant ultimate approach that let you execute any gulp task you may have with the bin symbolic link fix with a command like &lt;strong&gt;&lt;em&gt;npm run gulp anytask&lt;/em&gt;&lt;/strong&gt;, check it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;...(content on your package.json)...
&#34;scripts&#34;: {
&#34;test&#34;: &#34;gulp test&#34;,
&#34;gulp&#34;: &#34;gulp&#34;
}
...(more content on your package.json)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Other examples&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;And as I mentioned I&amp;#8217;m not talking about just gulp, eslint is another good example of this concept but in a slightly different way, you can configure your IDE to use some global eslint set of rules, but &lt;em&gt;every project may have different rules, and this is a real conflict too because one maybe is in es5 and the other one in ECMAScript 2015&lt;/em&gt;, and there lots of examples. &lt;em&gt;Grunt also applies&lt;/em&gt;&lt;strong&gt;,&lt;/strong&gt; you can stop using the global grunt by following this steps too (installing grunt-cli locally instead). Want more? Mocha, some Babel versions. And the list is long. Of course, they are creating a module, they want it to be easy so more developers adopt it. And it’s true, it works, they get more engagement on their modules. But at some point we need to know where to stop and grow from our experience.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So in conclusion, I think every project should be self sufficient, self configured, and this approach tries to tackle that. If you create a node.js project you need to stick to the node.js interpreter as a requirement. Nothing global except for that container platform itself which is a natural requirement for your scripts. In this way, if some day another task runner came out and kills gulp, or any pseudo global CLI, you can smoothly switch to the new one. Also you don&amp;#8217;t couple the learning curve from the CLI to your module user&amp;#8217;s, and you don&amp;#8217;t share CLI dependencies between your different projects you may have, letting you have different project with different versions without forcing you to refresh them all.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Please any comment, suggestion, typo, send it to nicosommi@gmail.com&lt;/p&gt;

&lt;p&gt;Thanks for reading.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debugging node</title>
      <link>http://nicosommi.github.com/index.php/2014/05/02/debugging-node/</link>
      <pubDate>Fri, 02 May 2014 01:39:40 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2014/05/02/debugging-node/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://nicosommi.com/?p=250&#34; title=&#34;Debugueando node&#34;&gt;&lt;em&gt;Para ver este artículo en español click aquí.&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When we write scripts on node.js there is always some things flying around our minds.There is a lot of things to think about. Is simple, but you need to know what are you doing because if you don&amp;#8217;t you can get into a mess quickly. Javascript. npm. The good, the bad and the uggly.&lt;/p&gt;

&lt;p&gt;One of the things that scared me the most in this node-hell at my begining was the debug method. Some of us are used to use frequently different kinds of logging utilities, from the built in console object to cool npm packages like debug, ain2, winston, etc. But what about the old well known debug process? Yes! I&amp;#8217;m talking about that one that allow us to watch expressiones in the current context, view the backtrace, and that kind of things.&lt;/p&gt;

&lt;p&gt;In my experience I was debugging node when I started to use it, but in a heavy way. Using eclipse. I came from Java so that was familiar for me and the V8 eclipse plugin works great and it&amp;#8217;s easy to use. You just start node with &amp;#8211;debug flag and connect the plugin to that port. It&amp;#8217;s a very good alternative. You can also use Chrome browser the same way. But today I&amp;#8217;m working on a lighter environment. Now I use Sublime Text and Gedit. Lose the fear to the console is something that we must do. Many of us learn that from ubuntu, git and such. Lose the fear to the console is actually a key part for a light and easy debug with node.&lt;/p&gt;

&lt;p&gt;So easy as the well known debugger on complex IDE but in the console. Some programmers are used to this kind of debugging, but for people that worked mostly with Java, C#, TIBCO and that kind of high level programming languages that is not the common thing and this was my first time debugging through the console for real.&lt;/p&gt;

&lt;p&gt;First of all let&amp;#8217;s take a look at the need. This came from real environments in which you have to solve a complexs issues all the time. Console logging sometimes does not give us the flexibility we need and in the time we need to know what is happening. Sometimes is just difficult to reproduce just one execution of some case. Many people can discuss about this and some maybe prefer to just trust in his skills&amp;#8230; I don&amp;#8217;t, I just prefer to not feel that pressure, I just want to know how to debug and detect problems watching the environment and using the tools the language provides for doing that.&lt;/p&gt;

&lt;p&gt;Well&amp;#8230; now that we know the benefits, let&amp;#8217;s go deep on how do you do this. It&amp;#8217;s so simple&amp;#8230; like everything in js. We just need to put the  &lt;strong&gt;debugger;&lt;/strong&gt; sentence in the places that we want, taking care of the asynchrounous nature of most apps on node, of course. Then we just execute the app with the debug argument&amp;#8230;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;node debug script.js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That simple. That leave us in the debug console. Now is easy, but from command line. Command we are use to execute with F8, F10, and all that, now are commands like &amp;#8216;n&amp;#8217;, &amp;#8216;s&amp;#8217;, &amp;#8216;c&amp;#8217;, or &amp;#8216;repl&amp;#8217;. Yes, n is for next, s if for step into, c is for continue or run. Repl is for entering to a console to eval.&lt;/p&gt;

&lt;p&gt;The command list is obviously on the official documentation here &lt;a href=&#34;http://nodejs.org/api/debugger.html&#34; title=&#34;http://nodejs.org/api/debugger.html&#34;&gt;http://nodejs.org/api/debugger.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As I pre-announced some, the most used are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;step in: just with s&lt;/li&gt;
&lt;li&gt;step out: writing o&lt;/li&gt;
&lt;li&gt;next step: n&lt;/li&gt;
&lt;li&gt;pause (just writing that)&lt;/li&gt;
&lt;li&gt;watch(&amp;#8216;variableName&amp;#8217;) : this will print the variable value on each step&lt;/li&gt;
&lt;li&gt;unwatch(&amp;#8216;variableName&amp;#8217;) : delete some watch to stop printing it&lt;/li&gt;
&lt;li&gt;list(4) : prints the context in a 4 line radious of the code, you can provide some other number&lt;/li&gt;
&lt;li&gt;repl : very important it allows as I said before to eval something in the current context like the browser&amp;#8217;s console (we can see but we can&amp;#8217;t modify ). Exit with CTRL+C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is extra &amp;#8220;problems&amp;#8221; to people who use gulp or grunt (almost everyone) to execute some previous task before running. But if that is your case you can use for example nodemon with the nodeArgs option like this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodemon({script: &#39;./app.js&#39;, nodeArgs: [&#39;debug&#39;]})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Another common case: test unit. With debug? Yes. For example if we execute&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mocha debug test/example.js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;then we also get the debugger.&lt;/p&gt;

&lt;p&gt;Combining mocha and grunt/gulp you can do this currently (also with nodemon):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodemon({script: &#39;./node_modules/mocha/bin/_mocha&#39;, nodeArgs: [&#39;debug&#39;]});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;where you put your path to the _mocha (with the underscore, is just a file on the mocha module) file on the script option. And you get your test on debug with your previous tasks configured.&lt;/p&gt;

&lt;p&gt;You get a ENOSPC Error?&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s because of too many files open (either or you have an editor like Sublime or nodemon is including too much files).&lt;/p&gt;

&lt;p&gt;You can solve this by increasing the max_user_watches with this command&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo sysctl fs.inotify.max_user_watches=20000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The correct number depends on your needs. You can see your current by executing this&lt;/p&gt;

&lt;p&gt;&lt;code&gt;more /proc/sys/fs/inotify/max_user_watches&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Also remember to execute nodemon with the -i node_modules argument.&lt;/p&gt;

&lt;p&gt;So, if you didn&amp;#8217;t do this yet, do it, is easy and very useful. Just do a simple for script and try it by yourself. Is going to make your life easier.&lt;/p&gt;

&lt;p&gt;Do you have an idea to improve this article? tell me to nicosommi@gmail.com&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BW-REST</title>
      <link>http://nicosommi.github.com/index.php/2013/12/02/bw-rest-2/</link>
      <pubDate>Mon, 02 Dec 2013 01:41:11 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2013/12/02/bw-rest-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://nicosommi.com/?p=174&#34; title=&#34;BW-REST&#34;&gt;&lt;em&gt;Para ver este artículo en español click aquí.&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; TIBCO Announciates his support for REST Webservice finally from ActiveMatrix 6.0.&lt;/p&gt;

&lt;p&gt;When we are working with Tibco BusinessWorks it&amp;#8217;s becoming more frequent the need to provide a REST API, just as the rest of the world. BW-REST goes beyond that and not only gives you the posibility to expose you services as a REST API, but also allows you to build an entire web application with HTML Templating, Cookies, Static resource routing, etc. It can be useful for several use cases like creating a rapid web application with latest javascript frameworks because you don&amp;#8217;t want another layer on your app. Because you came from GI. Because you don&amp;#8217;t want to spend more money on another developer. Because you don&amp;#8217;t want to bring another error point to your application. Because you just need a little app to mantain the entities inside that project. Just a few cases. With BW-REST you can develop a complete web application like in the example: using backbone, require.js, jquery-ui, coffeescript, etc. It&amp;#8217;s open source!&lt;/p&gt;

&lt;p&gt;&lt;a title=&#34;repo&#34; href=&#34;http://github.com/nicosommi/bw-rest&#34; target=&#34;_blank&#34;&gt;You can found it here &lt;a href=&#34;http://github.com/nicosommi/bw-rest&#34;&gt;http://github.com/nicosommi/bw-rest&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See the video here!&lt;/p&gt;

&lt;p&gt;Features v 0.1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JADE templating support&lt;/li&gt;
&lt;li&gt;Controller support&lt;/li&gt;
&lt;li&gt;Project-relative paths&lt;/li&gt;
&lt;li&gt;Support for regular expressions&lt;/li&gt;
&lt;li&gt;Support query string and url parameters&lt;/li&gt;
&lt;li&gt;Static resource support (recursivelly)&lt;/li&gt;
&lt;li&gt;Built in implementation customizable by defaultvars&lt;/li&gt;
&lt;li&gt;Cookie support&lt;/li&gt;
&lt;li&gt;Multiple server on the same project/archive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LICENSE: LGPL v3 ©2013 BW-REST&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explore BW-TEST</title>
      <link>http://nicosommi.github.com/index.php/2013/12/02/explore-bw-test-2/</link>
      <pubDate>Mon, 02 Dec 2013 01:38:50 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2013/12/02/explore-bw-test-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://nicosommi.com/?p=209&#34; title=&#34;Explorando BW-TEST&#34;&gt;&lt;em&gt;Para ver este artículo en español click aquí.&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is really easy! Look the video!&lt;/p&gt;

&lt;p&gt;BW-TEST is another open source library. This one is for automating your tests. This time you will be able to do your tests within TIBCO Designer. It allows you to integrate your BusinessWorks developed project to your continuous integration server like jenkins. Also, it allows you to practice TDD! So, you can automate your test. You offer a better service. You use the same tool. You save time and money. Features&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xunit compatible (tested with jenkins)&lt;/li&gt;
&lt;li&gt;multiple assertion support by using Assertions.process once in your test&lt;/li&gt;
&lt;li&gt;test suites support&lt;/li&gt;
&lt;li&gt;xml and html reports&lt;/li&gt;
&lt;li&gt;startup once running&lt;/li&gt;
&lt;li&gt;support running on every request&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can found the source code in &lt;a href=&#34;http://github.com/nicosommi/bw-test&#34; title=&#34;bw-test&#34;&gt;http://github.com/nicosommi/bw-test&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;License LGPL v3 ©2013 BW-TEST&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>