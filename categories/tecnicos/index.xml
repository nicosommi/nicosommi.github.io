<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tecnicos on nicosommi</title>
    <link>http://nicosommi.github.com/categories/tecnicos/</link>
    <description>Recent content in Tecnicos on nicosommi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-AR</language>
    <lastBuildDate>Sun, 20 Apr 2014 15:17:15 +0000</lastBuildDate>
    <atom:link href="http://nicosommi.github.com/categories/tecnicos/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Debugueando node</title>
      <link>http://nicosommi.github.com/index.php/2014/04/20/debugging-node-seriously/</link>
      <pubDate>Sun, 20 Apr 2014 15:17:15 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2014/04/20/debugging-node-seriously/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://nicosommi.com/?p=284&#34; title=&#34;Debugging node&#34;&gt;&lt;em&gt;To see this article in english click here.&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cuando programamos en Node.js siempre hay cositas que vuelan por la cabeza. Hay muchas cosas en las que pensar. Muchas cosas que tener en cuenta. Es simple, pero hay que saber lo que se está haciendo al altísimo precio de llegar a un lío muy importante. Javascript. Npm. Lo bueno, lo malo y lo feo.&lt;/p&gt;

&lt;p&gt;Una de las cosas que más me asustaban en este node-hell es poder depurar nuestro script. Muchos solemos usar muy frecuentemente logging de distintos tipos, desde el simple console.log hasta paquetes más copados como debug, ain2, winston o algo así. Pero muchos evaden el viejo y conocido debug, que nos permite agregar watch expressions, evaluar ejecuciones en el contexto actual, observar el backtrace, y otras cositas mas.&lt;/p&gt;

&lt;p&gt;En mi experiencia había debuggeado previamente node en mis comienzos, pero de una forma muy distinta. Usando eclipse. Vengo de Java así que me resultaba familiar, y el debugger V8 se conecta sin problemas a un proceso node ejecutando en modo debug (con &amp;#8211;debug). Sin lugar a dudas es una muy buena alternativa. Sin embargo hoy tengo un entorno de desarrollo mucho más dinámico y liviano en memoria. También puedo abrir el chrome y hacer lo mismo que del eclipse pero desde ahí. Pero hay dos motivos en contra de eso: los que no usamos Chrome (yo uso Firefox por ahora) y los que encima no desarrollamos necesariamente algo web con node.js y no necesitamos abrir el browser. Gedit y Sublime son los editores que uso frecuentemente. Perder el miedo a la consola es algo que aprendemos todos los que somos habitué de ubuntu, git, y esas cosas. Perder el miedo a la consola es también clave para no complicarse la vida con la depuración en node.js.&lt;/p&gt;

&lt;p&gt;Es tan sencillo como lo siguiente: es un debugger como los que conocemos de toda la vida pero comandado por consola. Desde algunos lenguajes ya vienen acostumbrados a esto, sin embargo yo que vengo de Java, y anteriormente C# y TIBCO, estoy acostumbrado a debuggers de todo tipo pero es la primera vez que experimento con la consola.&lt;/p&gt;

&lt;p&gt;Primero que nada repasemos la necesidad. Esto surge de la experiencia en ambientes reales en donde solucionar un problema complejo en ambientes productivos es algo habitual. Los logging de consola algunas veces son precarios en algunos aspectos y nos limitan a la hora de solucionar un problema rápidamente. Muchos podrán discutir sobre este tema apoyados en su rapidez y lucidez mental constante. Yo prefiero saber que no dependo de eso. Prefiero no sentir esa presión. Prefiero saber como debuggear y detectar el problema mirando mejor el contexto. Demás está decir que algunas veces los errores son tan complicados que la reproducción del mismo nos lleva mucho tiempo y sincronización, y por ende estaría buenísimo si descubrimos el error en la menor cantidad de intentos posibles.&lt;/p&gt;

&lt;p&gt;Mencionados ya los beneficios de usar un debugger, vayamos al acto. El uso trivial es sencillo: ponemos un debugger; en donde nos plazca y luego ejecutamos la aplicación con el argumento debug.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;node debug script.js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Algo tan simple como eso ya nos deja en la consola de debug. Ahora es sencillo, para lo que antes haciamos en entornos gráficos ahora tenemos un string que dispara el comando. Por ejemplo poniendo &amp;#8216;cont&amp;#8217; o &amp;#8216;c&amp;#8217; el debugger avanzará hasta el próximo debugger;&lt;/p&gt;

&lt;p&gt;Hay una lista completa de comandos en la sección Commands reference en el siguiente link &lt;a href=&#34;http://nodejs.org/api/debugger.html&#34; title=&#34;http://nodejs.org/api/debugger.html&#34;&gt;http://nodejs.org/api/debugger.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Los más destacados son&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;step in: se hace escribiendo s&lt;/li&gt;
&lt;li&gt;step out: escribiendo o&lt;/li&gt;
&lt;li&gt;next step: n&lt;/li&gt;
&lt;li&gt;pause&lt;/li&gt;
&lt;li&gt;watch(&amp;#8216;variableName&amp;#8217;) : imprimira el valor en cada paso&lt;/li&gt;
&lt;li&gt;unwatch(&amp;#8216;variableName&amp;#8217;) : dejara de monitorear el valor&lt;/li&gt;
&lt;li&gt;list(4) : imprime el contexto en un radio de 4 lineas&lt;/li&gt;
&lt;li&gt;repl : importantísimo, nos permite evaluar algo en el contexto actual como el console del browser (tenemos todo lo del contexto pero no podemos modificarlo). Salimos con ctrl+c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hay &amp;#8220;complicaciones&amp;#8221; extra para quienes utilizan gulp/grunt (casi todos) ejecutando algunas tareas previas a iniciar la aplicación&amp;#8230; pero buenas noticias, se puede utilizar algo como por ejemplo nodemon en esos casos, con la opción nodeArgs.&lt;/p&gt;

&lt;p&gt;Por ejemplo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodemon({script: &#39;./app.js&#39;, nodeArgs: [&#39;debug&#39;]})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Otro caso común. Test unit. Con debug? Sí. Por ejemplo si ejecutamos&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mocha debug test/ejemplo.js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;entonces nos llevará a la consola de debug.&lt;/p&gt;

&lt;p&gt;Combinando mocha y grunt/gulp se puede hacer esto (también con nodemon):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodemon({script: &#39;./node_modules/mocha/bin/_mocha&#39;, nodeArgs: [&#39;debug&#39;]});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;donde ponés la ruta a tu instalación global del ejecutable _mocha (con guión bajo) y listo, con eso tenés tus test con el debugger built in y tus tareas previas ejecutadas.&lt;/p&gt;

&lt;p&gt;Obteniendo un error ENOSPC?&lt;/p&gt;

&lt;p&gt;Eso es porque hay muchos archivos abiertos (o tenés un editor que suele abrir muchos archivos como Sublime o nodemon está incluyendo muchos archivos).&lt;/p&gt;

&lt;p&gt;Lo podés solucionar incrementando el valor de max_user_watches con este comando&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo sysctl fs.inotify.max_user_watches=20000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;El número correcto depende de tus necesidades. Podés ver que tenés actualmente ejecutando esto&lt;/p&gt;

&lt;p&gt;&lt;code&gt;more /proc/sys/fs/inotify/max_user_watches&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;También recordá executar nodemon con el argumento -i nodemodules&lt;/p&gt;

&lt;p&gt;En definitiva. Si todavía no lo hiciste animate que es sencillo. Hace un script sencillo que cuente hasta 100 en un for y probalo vos mismo.&lt;/p&gt;

&lt;p&gt;Tenés una idea para mejorar este artículo? Mandámela a nicosommi@gmail.com&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explorando BW-TEST</title>
      <link>http://nicosommi.github.com/index.php/2013/12/05/explore-bw-test/</link>
      <pubDate>Thu, 05 Dec 2013 21:11:21 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2013/12/05/explore-bw-test/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://nicosommi.com/?p=287&#34; title=&#34;Explore BW-TEST&#34;&gt;&lt;em&gt;To see this article in english click here.&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Es muy simple! Mirá el video!&lt;/p&gt;

&lt;p&gt;BW-TEST es otra librería open source. Esta es para automatizar tus test. Esta vez vas a poder tus test con TIBCO Designer. Te permite integrar Business Works a tu servidor de integracion contínua como Jenkins. También te permite practicar TDD! Entonces, repasando: ahorras dinero porque perdes menos tiempo testeando, ofreces un mejor servicio y de mayor calidad con el servidor de integracion continua.&lt;/p&gt;

&lt;p&gt;Caracteristicas&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xunit compatible (tested with jenkins)&lt;/li&gt;
&lt;li&gt;multiple assertion support by using Assertions.process once in your test&lt;/li&gt;
&lt;li&gt;test suites support&lt;/li&gt;
&lt;li&gt;xml and html reports&lt;/li&gt;
&lt;li&gt;startup once running&lt;/li&gt;
&lt;li&gt;support running on every request&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Podes encontrar el codigo fuente aca: &lt;a href=&#34;http://github.com/nicosommi/bw-test&#34; title=&#34;bw-test&#34;&gt;http://github.com/nicosommi/bw-test&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Licencia LGPL v3 ©2013 BW-TEST&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BW-REST</title>
      <link>http://nicosommi.github.com/index.php/2013/10/18/bw-rest/</link>
      <pubDate>Fri, 18 Oct 2013 01:54:52 +0000</pubDate>
      
      <guid>http://nicosommi.github.com/index.php/2013/10/18/bw-rest/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://nicosommi.com/?p=291&#34; title=&#34;BW-REST&#34;&gt;&lt;em&gt;To see this article in english click here.&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA:&lt;/strong&gt; TIBCO finalmente anunció soporte para web services REST desde ActiveMatrix 6.0.&lt;/p&gt;

&lt;p&gt;Cuando trabajamos con TIBCO BusinessWorks se vuelve cada vez mas frecuente la necesidad de proveer una API REST como el resto del mundo. BW-REST va mas alla y no solo te da esa posibilidad sino que tambien te permite construir una aplicacion web completa con HTML Templating, Cookies, Static resource routing, etc. Puede ser util en muchos casos de uso como crear una aplicacion web rapidamente y con los ultimos frameworks javascript. Porque no queres otra capa en tu aplicacion. Porque venis de GI. Porque no podes gastar mas dinero en otro desarrollador. Porque no queres introducir un nuevo punto de falla en la aplicacion. Porque simplemente necesitas una pequena aplicacion para mantener las entidades manipuladas en tu proyecto. Son tan solo algunos casos. Con BW-REST podes hacer aplicaciones como las del ejemplo: usando backbone, require.js, jquery-ui, coffeescript, etc.&lt;/p&gt;

&lt;p&gt;Es de codigo abierto! &lt;a title=&#34;repo&#34; href=&#34;http://github.com/nicosommi/bw-rest&#34; target=&#34;_blank&#34;&gt;You can found it here &lt;a href=&#34;http://github.com/nicosommi/bw-rest&#34;&gt;http://github.com/nicosommi/bw-rest&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mira el video!&lt;/p&gt;

&lt;p&gt;Caracteristicas v 0.1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JADE templating support&lt;/li&gt;
&lt;li&gt;Controller support&lt;/li&gt;
&lt;li&gt;Project-relative paths&lt;/li&gt;
&lt;li&gt;Support for regular expressions&lt;/li&gt;
&lt;li&gt;Support query string and url parameters&lt;/li&gt;
&lt;li&gt;Static resource support (recursivelly)&lt;/li&gt;
&lt;li&gt;Built in implementation customizable by defaultvars&lt;/li&gt;
&lt;li&gt;Cookie support&lt;/li&gt;
&lt;li&gt;Multiple server on the same project/archive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Licencia LGPL v3 ©2013 BW-REST&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>