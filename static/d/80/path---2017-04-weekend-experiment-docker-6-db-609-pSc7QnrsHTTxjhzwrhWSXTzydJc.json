{"data":{"markdownRemark":{"html":"<p><em>Let's build a small node.js single page application (SPA) using the multi stage builds feature from docker to optimize the image size</em></p>\n<h2>Introduction</h2>\n<p>With multi stage builds (a feature announced in the docker con last week) we can create a tiny image that get's pulled and pushed faster to the docker repository.</p>\n<p>A Single Page Applications (SPA's) is a convenient use case to test the power of multi stage build easily in the node.js world.</p>\n<p>Let's start with this.</p>\n<h3>First step: install docker 17.05-ce</h3>\n<p>Easy, go to <a href=\"https://www.docker.com/community-edition#/download\">https://www.docker.com/community-edition#/download</a>\nChoose your platform AND, because we need multi stage builds and its still on the <em>edge channel</em> we need to choose that instead of the stable channel. Download, install.</p>\n<h3>Second step: Building a SPA</h3>\n<p>A single page application is just a static web page that can be served through any traditional web server.</p>\n<p>For this example, let's pick a boilerplate SPA like create-react-app.</p>\n<pre><code class=\"language-shell\">npm install -g create-react-app\n\ncreate-react-app my-app\ncd my-app/\nnpm start # if you want to test it and check the browser for it\n</code></pre>\n<h3>Third step: create a Dockerfile</h3>\n<p>All right now the important thing, let's take a look at a candidate Dockerfile</p>\n<pre><code class=\"language-docker\"># buildtime\nFROM node AS nodebase\nLABEL maintainer \"nicosommi@gmail.com\"\n\nADD . /usr/src/app\nWORKDIR /usr/src/app\nRUN npm i &#x26;&#x26; npm run build\n\n# runtime\nFROM nginx:alpine\nCOPY --from=nodebase /usr/src/app/build /usr/share/nginx/html\n</code></pre>\n<p>So let's see.</p>\n<p>We start with a node:latest image, no problem with the image size because now we have multi stage builds.</p>\n<p>The LABEL maintainer, that's recent too, no more MAINTAINER special instruction, now it's a label.</p>\n<p>We add the current directory to the appropiate location and set the working directory to it.</p>\n<p>Install, build... and that's all that we need to generate our artifacts in our build folder.</p>\n<p>So after that, we take for the runtime the small nginx:alpine image and we just copy the build folder to the right place.</p>\n<p>Done!</p>\n<h3>Fourth step: build and run!</h3>\n<p>So now, let's build the image\n<code>docker build -t my-app .</code></p>\n<p>And now let's look it's size\n<code>docker images</code></p>\n<p>All right! less than 16 MB! With the whole thing, linux, nginx and our app!</p>\n<p>That's great. Just the node_modules folder size after installation is around 130 MB... so this is a BIG win.</p>\n<p>Let's try it<br>\n<code>docker run -d --rm -p 8000:80 --name my-app my-app</code></p>\n<p>Open chrome in localhost:8000 and enjoy.</p>\n<h2>Conclusion</h2>\n<p>Multi stage builds are great, it let's you easily build whatever you want and then create a thin self-sufficient pack with exactly what you need to let the user run your application.</p>\n<p>By making this clear distinction between different stages, docker let's you think in a more organized way about the Dockerfile.</p>\n<p>With multi stage builds the LAST stage is the one that is used on your final image. Don't forget that. <em>For example, the ONBUILD instruction on a previous stage wont have any effect</em> because it will be overwritten with the last stage of the Dockerfile.</p>\n<p>As a side note, it is important to say that this may be a trigger to massively use webpack or some kind of bundler for standalone node.js applications. The node_modules folder get's really big very quickly.</p>","frontmatter":{"date":"April 29, 2017","url":"/2017/04/weekend-experiment-docker","title":"Weekend experiment: a node.js SPA with multi stage builds from docker","author":"nico","categories":null,"tags":null,"type":null}}},"pageContext":{}}