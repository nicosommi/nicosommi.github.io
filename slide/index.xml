<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slides on nicosommi</title>
    <link>http://nicosommi.github.com/slide/</link>
    <description>Recent content in Slides on nicosommi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-AR</language>
    <lastBuildDate>Wed, 29 Mar 2017 15:38:10 -0300</lastBuildDate>
    <atom:link href="http://nicosommi.github.com/slide/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker secrets</title>
      <link>http://nicosommi.github.com/slide/docker.secrets/</link>
      <pubDate>Wed, 29 Mar 2017 15:38:10 -0300</pubDate>
      
      <guid>http://nicosommi.github.com/slide/docker.secrets/</guid>
      <description>

&lt;!-- class: middle --&gt;

&lt;!-- layout: true --&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;http://nicosommi.github.com/assets/2017-03-25-13-39-09.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;docker-secrets&#34;&gt;Docker secrets&lt;/h1&gt;

&lt;h2 id=&#34;por-nicosommi&#34;&gt;Por nicosommi&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;name: agenda&lt;/p&gt;

&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Agenda e introducción&lt;/li&gt;
&lt;li&gt;Como surgen?&lt;/li&gt;
&lt;li&gt;¿Qué son los secrets?&lt;/li&gt;
&lt;li&gt;¿Para que sirven?&lt;/li&gt;
&lt;li&gt;Anotaciones de seguridad&lt;/li&gt;
&lt;li&gt;Detalles de utilización&lt;/li&gt;
&lt;li&gt;Preparando nuestras imágenes&lt;/li&gt;
&lt;li&gt;Creando un secreto sencillo&lt;/li&gt;
&lt;li&gt;Utilizando secrets con YML&amp;rsquo;s de docker compose&lt;/li&gt;
&lt;li&gt;Usando https con secrets&lt;/li&gt;
&lt;li&gt;Resumen de comandos&lt;/li&gt;
&lt;li&gt;Q &amp;amp; A&lt;/li&gt;
&lt;li&gt;Fin&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;como-surgen&#34;&gt;¿Como surgen?&lt;/h2&gt;

&lt;p&gt;Porque la comunidad toma decisiones heterogeneas y peligrosas:
- Usar variables de entorno (12 factor app)
- Variables de entorno en build
- Manual build (commit)
- Custom hacks (curl a webserver)
&amp;hellip; Se necesitan do&amp;rsquo;s and don&amp;rsquo;ts&lt;/p&gt;

&lt;p&gt;???
- accesibles por cualquier proceso, guardada en capas intermedias, compartidas para otros contenedores linkeados&lt;/p&gt;

&lt;h2 id=&#34;hasta-se-decidio-no-encriptarlas-solo-para-que-la-gente-no-las-use-para-secretos&#34;&gt;- hasta se decidio no encriptarlas solo para que la gente no las use para secretos&lt;/h2&gt;

&lt;h2 id=&#34;qué-son-los-secrets&#34;&gt;¿Qué son los secrets?&lt;/h2&gt;

&lt;p&gt;Para docker es un BLOB de datos manejado de manera centralizada.
- Compartido para los servicios del swarm que lo necesitan, solo mientras estos ejecutan
- Solo para swarm&amp;hellip; por ahora
- Hasta 500KB (no TAN large)
- Por ahora solo para runtime
&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/slide/assets/2017-03-22-21-47-13.png&#34; width=&#34;800px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;???
Binary Large OBjects
Secure Sockets Layer (ahora Transport Layer Security)
SwarmKit es una libreria que se encarga del node management&lt;/p&gt;

&lt;h2 id=&#34;hay-un-issue-en-curso-para-build-time-secrets&#34;&gt;Hay un issue en curso para build time secrets&lt;/h2&gt;

&lt;h2 id=&#34;para-que-sirven&#34;&gt;¿Para que sirven?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Para guardar certificados SSL, SSH Keys, Username y Passwords, nombres de bases de datos&amp;hellip; y cualquier dato sensible que debe estar en runtime, pero no en la imagen ni en el control de versiones&lt;/li&gt;
&lt;li&gt;Funciona como capa de abstraccion entre las credenciales y los contenedores&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
- En los distintos ambientes puedo tener credenciales con el mismo nombre pero distinto contenido y entonces el contenedor es exactamente igual mas alla de que los secrets cambien de contenido&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;anotaciones-de-seguridad&#34;&gt;Anotaciones de seguridad&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Viajan a los managers del swarm por TLS&lt;/li&gt;
&lt;li&gt;Se almacenan en el Raft log, con todo lo que ello nos garantiza (que está encriptado y es replicado a través de los managers, garantizando la misma HA que el resto de la informacion del swarm)&lt;/li&gt;
&lt;li&gt;Cuando se detiene un container, se hace unmount y se flushea la memoria&lt;/li&gt;
&lt;li&gt;Si se pierde conexión con el swarm, se tiene acceso al secret, pero no puede recibir ninguna instrucción hasta que se vuelva a conectar al swarm&lt;br /&gt;
&lt;a href=&#34;http://thesecretlivesofdata.com/raft/&#34;&gt;http://thesecretlivesofdata.com/raft/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
* Esta encriptado desde la 1.13
* El rotado de secrets es basicamente actualizar el servicio con el secret viejo y el nuevo, proceder a cambiarlo en el servicio, luego borrarlo del servicio y finalmente borrarlo del swarm
* El &amp;ldquo;Raft log&amp;rdquo; se refiere al consensus algorithm que utiliza swarmkit &lt;em&gt;entre managers&lt;/em&gt; para coordinar nodos y no depender de un solo punto de falla para tomar decisiones. Raft fue diseñado para ser simple de entender y que más sistemas utilizen un buen algoritmo de consenso para ser más tolerantes a fallas. Consiste en un simple sistema de eleccion de lider y de propagacion de estado. Define followers, candidatos y líderes.
* Cuando no hay lideres, se inician las rondas de timeout random para que un nodo se vuelva candidato, vote por si mismo y reciba votos de los otros nodos. Las rondas terminan cuando un líder es elegido. Después hay un heartbeat timeout y cuando se pierde el lider se hace la re eleccion.
&lt;a href=&#34;http://thesecretlivesofdata.com/raft/&#34;&gt;http://thesecretlivesofdata.com/raft/&lt;/a&gt;
Tienen un log y una maquina de estados.
Si una parte del cluster se cae, el que tiene mayoria igual puede impactar, los que no tienen mayoria dejan pendiente, y cuando reciben el mensaje de quien tenia mayoria, hacen rollback y acceden al cambio del lider que tiene mayoria, también relegando su liderazgo.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;detalles-de-utilización&#34;&gt;Detalles de utilización&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Se montan en /run/secrets/name&lt;/li&gt;
&lt;li&gt;Solo tiene acceso si es un manager o si tiene permisos específicos&lt;/li&gt;
&lt;li&gt;Se pueden ver, listar los secrets, pero no se puede borrar uno que está siendo utilizado, para ello se debe rotar el secret&lt;/li&gt;
&lt;li&gt;Se recomienda poner en el nombre una fecha o numero de version, para hacer más sencillo el control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
- &amp;ndash;secret source=mysql_password,target=wp_db_password,mode=0400&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;preparando-nuestras-imágenes&#34;&gt;Preparando nuestras imágenes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Para hacer nuestras imagenes secrets-friendly debemos brindar, tal como lo hizo wordpress, una alternativa de archivos a la environment variable que clasicamente se utiliza (MYSQL_PASSWORD_FILE además de MYSQL_PASSWORD)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;creando-un-secreto-sencillo&#34;&gt;Creando un secreto sencillo&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker swarm init --advertise-addr eth0 # solo para probar local
$ openssl rand -base64 20 | docker secret create mi_secreto -
$ docker service create --name mi_servicio --secret mi_secreto nginx
$ docker exec $(docker ps --filter name=mi_servicio -q) ls /run/secrets
$ docker exec $(docker ps --filter name=mi_servicio -q) cat /run/secrets/mi_secreto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
Si commiteamos el container a una imagen, el secreto es desmontado&lt;/p&gt;

&lt;h2 id=&#34;si-tengo-mas-replicas-el-comando-debe-ser-adaptado-porque-hay-mas-de-un-hash-tengo-que-hacerlo-mas-a-mano&#34;&gt;Si tengo mas replicas el comando debe ser adaptado porque hay mas de un hash, tengo que hacerlo mas a mano&lt;/h2&gt;

&lt;h2 id=&#34;utilizando-secrets-con-yml-s-de-docker-compose&#34;&gt;Utilizando secrets con YML&amp;rsquo;s de docker compose&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;3.1&#39;
services:
    test:
        image: &#39;alpine&#39;
        command: &#39;cat /run/secrets/my_secret&#39;
        secrets: 
            - my_secret
secrets:
    my_secret:
        file: ./mysecret.txt
        # o external: true para tomarlo del swarm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
Gracias al stack del compose&lt;/p&gt;

&lt;h2 id=&#34;docker-stack-deploy-c-file-yml-name&#34;&gt;docker stack deploy -c file.yml name&lt;/h2&gt;

&lt;h2 id=&#34;usando-https-con-secrets&#34;&gt;Usando https con secrets&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Generar certificado con let&amp;rsquo;s encrypt, self-signed u otra CA&lt;/li&gt;
&lt;li&gt;Preparar nginx config&lt;/li&gt;
&lt;li&gt;Preparar secrets en el swarm
&lt;code&gt;shell
$ docker secret create site.key site.key
$ docker secret create site.crt site.crt
$ docker secret create site.conf site.conf
&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Crear el servicio&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker service create --name nginx --secret site.key \
 --secret site.crt --secret site.conf --publish 3000:443 nginx:latest \
 sh -c &amp;quot;ln -s /run/secrets/site.conf /etc/nginx/conf.d/site.conf &amp;amp;&amp;amp; exec nginx -g &#39;daemon off;&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???&lt;/p&gt;

&lt;h2 id=&#34;daemon-off-es-un-flag-de-nginx-para-docker-o-debug-que-lo-mantiene-en-foreground-y-que-es-amigo-de-tener-un-proceso-por-container&#34;&gt;Daemon off es un flag de nginx para docker o debug que lo mantiene en foreground y que es amigo de tener un proceso por container&lt;/h2&gt;

&lt;h2 id=&#34;resumen-de-comandos&#34;&gt;Resumen de comandos&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker swarm init --advertise-addr eth0 # solo para probar local
$ echo &amp;quot;a&amp;quot; | docker secret create mi_secreto -
$ docker secret inspect mi_secreto
$ docker secret ls
$ docker service create --name mi_servicio --secret mi_secreto nginx
$ docker service update mi_servicio --secret-rm mi_secreto
$ docker service update mi_servicio --secret-add mi_nuevo_secreto
$ docker secret rm mi_secreto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???&lt;/p&gt;

&lt;h2 id=&#34;aca-se-pueden-ver-todos-los-comandos-necesarios-para-por-ejemplo-hacer-una-rotacion-de-logs&#34;&gt;Aca se pueden ver todos los comandos necesarios para por ejemplo hacer una rotacion de logs&lt;/h2&gt;

&lt;h1 id=&#34;q-a&#34;&gt;Q &amp;amp; A&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;gracias&#34;&gt;Gracias!&lt;/h1&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>docker</title>
      <link>http://nicosommi.github.com/slide/docker/</link>
      <pubDate>Mon, 24 Oct 2016 15:38:10 -0300</pubDate>
      
      <guid>http://nicosommi.github.com/slide/docker/</guid>
      <description>

&lt;!-- class: middle --&gt;

&lt;!-- layout: true --&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;http://nicosommi.github.com/assets/docker-74de8.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduccion-a-docker&#34;&gt;Introduccion a docker&lt;/h1&gt;

&lt;h2 id=&#34;por-nicosommi&#34;&gt;Por nicosommi&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;name: agenda&lt;/p&gt;

&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Agenda y alcance&lt;/li&gt;
&lt;li&gt;Fundamentos&lt;/li&gt;
&lt;li&gt;Casos de uso&lt;/li&gt;
&lt;li&gt;Por dentro&lt;/li&gt;
&lt;li&gt;Componentes&lt;/li&gt;
&lt;li&gt;Ejemplo sencillo&lt;/li&gt;
&lt;li&gt;Q &amp;amp; A&lt;/li&gt;
&lt;li&gt;Mas componentes&lt;/li&gt;
&lt;li&gt;Comandos sobre contenedores e imágenes&lt;/li&gt;
&lt;li&gt;Ejemplo lateral&lt;/li&gt;
&lt;li&gt;Técnica para construir un Dockerfile&lt;/li&gt;
&lt;li&gt;Buenas prácticas&lt;/li&gt;
&lt;li&gt;Docker para SPA, web apps, etc&lt;/li&gt;
&lt;li&gt;Anexo: Services&lt;/li&gt;
&lt;li&gt;Q &amp;amp; A&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;class: center&lt;/p&gt;

&lt;h2 id=&#34;que-es&#34;&gt;Que es?&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-89c82.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;???
Disculpen el teclado en ingles&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Técnicamente es una capa de abstracción para la utilización de cgroups, namespaces y UnionFS de linux.&lt;/li&gt;
&lt;li&gt;Basado en esto, crea el concepto de contenedor y nos permite construir de manera simple imagenes a partir de las cuales correr contenedores de manera aislada.&lt;/li&gt;
&lt;li&gt;UnionFS que consiste en poner una capa arriba de otra hasta lograr un sistema de archivos coherente&lt;/li&gt;
&lt;li&gt;Con los namespaces virtualiza los recursos como archivos, recursos de red y usuarios&lt;/li&gt;
&lt;li&gt;Con los cgroups aisla del uso de recursos (cpu, memoria, E/S)
&lt;center&gt;
&lt;img src=&#34;http://nicosommi.github.com/assets/docker-28b55.png&#34; width=&#34;300px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;class: right
&lt;img style=&#34;position: absolute&#34; src=&#34;http://nicosommi.github.com/assets/docker-04a7d.png&#34; width=&#34;200px&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h2 id=&#34;es-una-maquina-virtual-no&#34;&gt;Es una maquina virtual? No.&lt;/h2&gt;

&lt;h2 id=&#34;como-se-diferencia-de-una&#34;&gt;Como se diferencia de una?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Se diferencia porque no tiene un sistema operativo host y uno guest, sino que utiliza herramientas de un sistema operativo existente para la creacion de contenedores.
&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/history.png&#34; width=&#34;600px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;
???
Comentar:
* historia
* primero escalabilidad horizontal
* despues optimizar recursos
* adicionales: docker swarm independiente
Nos permite cambiar la unidad de medida de nuestra aplicación de máquinas virtuales o físicas a simples containers.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;en-donde-corre&#34;&gt;En donde corre?&lt;/h2&gt;

&lt;p&gt;En sus inicios solo soportaba contenedores linux sobre linux, ahora puede correr contenedores linux-based tanto en mac como en windows y en varios otros providers (aws, etc).
Tambien, recientemente incorporaron contenedores basados en windows server.
&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/platforms.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-6a999.png&#34; width=&#34;100px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-para-que-sirve&#34;&gt;&amp;nbsp;Para que sirve?&lt;/h2&gt;

&lt;p&gt;Para isolar el entorno de ejecución de una aplicación.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/pencil.png&#34; width=&#34;80px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-datos&#34;&gt;&amp;nbsp;Datos&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Es open source desde el 2013.&lt;/li&gt;
&lt;li&gt;Esta escrito en go.&lt;/li&gt;
&lt;li&gt;Lo comenzó Solomon Hykes en dotCloud.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
Go esta pensado para concurrencia y productividad y tiene garbage collection&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;casos-de-uso&#34;&gt;Casos de uso&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://nicosommi.github.com/assets/usecases.png&#34; width=&#34;90%&#34;&gt;&lt;/img&gt;
???
Invitar a sugerir ideas u opinar sobre las mencionadas
Texto:
* CI/CD
* Entornos de desarrollo
* Compilar para distintos targets
* PaaS
* Escalabilidad horizontal
* High availability cluster
* Aislar ejecucion de codigo de manera segura (webpackbin, etc)
* Aprendizaje/investigacion
* Etc&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;por-dentro&#34;&gt;Por dentro&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-c4f70.png&#34; width=&#34;140px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-docker-image&#34;&gt;&amp;nbsp;Docker Image&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Es un template con instrucciones para la construccion de contenedores&lt;/li&gt;
&lt;li&gt;Tiene una o varias capas de solo lectura a partir del cual se crean contenedores&lt;/li&gt;
&lt;li&gt;Se pueden extender o empezar de cero&lt;/li&gt;
&lt;li&gt;Para su descripcion se utiliza una simple interfaz en un archivo de texto denominado Dockerfile&lt;/li&gt;
&lt;li&gt;El Dockerfile contiene instrucciones, y cada instruccion genera una capa adicional. Estas instrucciones son por ejemplo FROM, MAINTAINER, RUN, ADD, ENV, CMD.&lt;/li&gt;
&lt;li&gt;Docker simplemente lee las instrucciones, las ejecuta, y devuelve la imagen&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;docker-container&#34;&gt;Docker Container&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Es una instancia de una imagen que se puede correr, parar, mover, borrar, etc.&lt;/li&gt;
&lt;li&gt;Contiene una fina capa adicional a las de su imagen con permisos de escritura.&lt;/li&gt;
&lt;li&gt;Adicionalmente puede contar con metadata, como puertos de red, variables de entorno, volumenes, etc.&lt;/li&gt;
&lt;li&gt;Cada contenedor es aislado pero puede tener acceso a recursos del host o de otros contenedores.
&lt;center&gt;
&lt;img src=&#34;http://nicosommi.github.com/assets/docker-bb91f.png&#34; width=&#34;300px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
Preguntar diferencia entre contenedor e imagen y clarificar dudas&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;acerca-del-contenedor&#34;&gt;Acerca del Contenedor&lt;/h2&gt;

&lt;p&gt;Previamente se utilizaba lxc, luego libcontainer, pero ahora se esta avocando a runC y a llevar adelante OCI (Open Container Initiative).
&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-71f58.png&#34; width=&#34;240px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-1c5ae.png&#34; width=&#34;70px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-storage&#34;&gt;&amp;nbsp;Storage&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Utiliza union fs, que consiste en poner una capa arriba de otra hasta lograr un sistema de archivos coherente&lt;/li&gt;
&lt;li&gt;Es quien se encarga de manejar los archivos entre las capas de solo lectura y la del contenedor&lt;/li&gt;
&lt;li&gt;Docker utiliza &amp;lsquo;copy on write&amp;rsquo;, es decir que copia una capa sólo cuando la va a cambiar, lo que permite optimizar el tamaño en disco ocupado por la imagen y el tiempo de arranque de los contenedores.&lt;/li&gt;
&lt;li&gt;Toda la data de imagenes y contenedores se guarda en una carpeta.&lt;/li&gt;
&lt;li&gt;Hay muchas variantes de union fs (drivers): aufs, overlay/2, btrfs, zfs. Se deben elegir según caso de uso, experiencia del equipo y linux distro.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;componentes&#34;&gt;Componentes&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;docker-engine&#34;&gt;Docker Engine&lt;/h2&gt;

&lt;p&gt;Aplicacion cliente/servidor. Un daemon es el servidor que levanta una API Rest la cual es utilizada por un CLI para instruirlo.
&lt;img src=&#34;http://nicosommi.github.com/assets/docker-9cf40.png&#34; alt=&#34;Docker engine&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;machine&#34;&gt;Machine&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Manager para windows, osx y otros providers, que nos permite correr un docker host y permite manejar multiples hosts en una red desde linux.&lt;/li&gt;
&lt;li&gt;Nos deja instalar docker en terminales remotas y provisionar swarms.
&lt;img src=&#34;http://nicosommi.github.com/assets/docker-7ada0.png&#34; width=&#34;95%&#34;&gt;&lt;/img&gt;
???
Permite especificar drivers para distintos providers&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;compose&#34;&gt;Compose&lt;/h2&gt;

&lt;p&gt;Es una herramienta para definir y correr aplicaciones que consisten de varios containers mediante la especificacion de un archivo docker-compose.yml.
* Detecta cambios y recrea solo lo necesario
* Soporta variables en el compose file
* Guarda la data persistida en los volumes
* Es muy util para entornos de desarrollo, para deployment en un solo host
&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-32d4f.png&#34; width=&#34;200px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/ubuntu.png&#34; width=&#34;50px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-ejemplo-sencillo&#34;&gt;&amp;nbsp;Ejemplo sencillo&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run --name miContenedor -it ubuntu:14.04 /bin/bash
root@3883936319fb:/# lsb_release -a
(...) Description:	Ubuntu 14.04.5 LTS (...)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Trae la ultima imagen, o si ya existe la utiliza.&lt;/li&gt;
&lt;li&gt;Crea, en base a la imagen, un contenedor.&lt;/li&gt;
&lt;li&gt;Guarda el contenedor en una carpeta y monta una capa con permisos de escritura.&lt;/li&gt;
&lt;li&gt;Asigna una interfaz de red con la cual habla con el host&lt;/li&gt;
&lt;li&gt;Setea una IP de una pool&lt;/li&gt;
&lt;li&gt;Ejecuta el proceso solicitado (/bin/bash)&lt;/li&gt;
&lt;li&gt;Captura y devuelve el output del contenedor por haber indicado -it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;???
i es para el interactive mode, que deja el stdin esperando
t asigna un pseudo tty / pty
* pull
* hablar de pull y de los otros parametros como name, port, volume&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;wordpress&#34;&gt;Wordpress&lt;/h2&gt;

&lt;pre&gt;
  &lt;code class=&#34;bash hljs remark-code remark-code-line&#34; style=&#34;font-size: 13px;&#34;&gt;
  version: &#39;2&#39;

  services:
     db:
       image: mysql:5.7
       volumes:
         - &#34;./.data/db:/var/lib/mysql&#34;
       restart: always
       environment: (...)

     wordpress:
       depends_on:
         - db
       image: wordpress:latest
       links:
         - db
       ports:
         - &#34;8000:80&#34;
       restart: always
       environment: (...)
  &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;???
Environment está cortado por cuestiones de espacio del slide pero es un ejemplo tomado de la página oficial&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;q-a-parcial&#34;&gt;Q &amp;amp; A Parcial&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;docker-registry&#34;&gt;Docker Registry&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Es una libreria de imagenes.&lt;/li&gt;
&lt;li&gt;Puede ser publico o privado.&lt;/li&gt;
&lt;li&gt;Una vez construida la imagen, hacemos un push al registry&lt;/li&gt;
&lt;li&gt;Docker hub es un registry publico oficial&lt;/li&gt;
&lt;li&gt;Hay una imagen publica registry y una para el trusted registry
&lt;center&gt;
&lt;img src=&#34;http://nicosommi.github.com/assets/docker-89504.png&#34; width=&#34;240px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;
???
Trusted registry es con soporte comercial&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;data-volumes&#34;&gt;Data volumes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Encontrar
&lt;code&gt;bash
$ docker inspect myContainer
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Se pueden crear volúmenes o montar desde el host
&lt;code&gt;bash
$ docker run -d -P --name web -v /webapp myImage npm start
$ docker run -d -P --name web -v /src:/webapp myImage npm start
&lt;/code&gt;
???&lt;/li&gt;
&lt;li&gt;bypass a unionfs&lt;/li&gt;
&lt;li&gt;si no esta bindeado a host, copia el contenido adentro&lt;/li&gt;
&lt;li&gt;permite compartir entre containers con compose o con named volumes (flocker por ejemplo)&lt;/li&gt;
&lt;li&gt;esta diseñado para cambiar el container y que la data persista, incluso aunque ningun container la referencie&lt;/li&gt;
&lt;li&gt;soporta SCSI, NFS, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;data-volume-containers&#34;&gt;Data volume containers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;a href=&#34;http://nicosommi.github.com/index.php/2016/09/06/contenedores-unicamente-de-volumenes-en-docker-volume-only-containers/&#34;&gt;Es una práctica&lt;/a&gt;&lt;/em&gt; que consiste en crear un contenedor que sólo contiene data que luego será utilizada por otros contenedores
&lt;code&gt;bash
$ docker create -v /dbdata --name mydb postgres /bin/true
$ docker run -d --volumes-from mydb --name db1 postgres
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;network&#34;&gt;Network&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Puede ser bridge, none  y host
&lt;code&gt;bash
$ docker network ls
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pueden verse los detalles
&lt;code&gt;bash
$ docker network inspect bridge
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Se pueden crear nuestras redes en las cuales correr containers
???&lt;/li&gt;
&lt;li&gt;un container puede pertenecer a varias redes&lt;/li&gt;
&lt;li&gt;se ven entre los de la misma red&lt;/li&gt;
&lt;li&gt;puede ser overlay (swarm mode) o custom driver&lt;/li&gt;
&lt;li&gt;embedded dns en custom networks&lt;/li&gt;
&lt;li&gt;antes habia links y ahora se solapa un poco con networks, comparte envs, escribe el hosts&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;docker-aplicado&#34;&gt;Docker Aplicado&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-28b55.png&#34; width=&#34;70px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-operaciones-sobre-contenedores&#34;&gt;&amp;nbsp;Operaciones sobre contenedores&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Run, Start, Stop&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# crea un contenedor en base a una imagen y corre el comando bash
$ docker run --name miContenedor alpine echo &amp;quot;Hola&amp;quot;
# arrancar un contenedor ya creado
$ docker start miContenedor
# parar contenedor con time to kill
$ docker stop -t 10 miContenedor
# also valid: docker restart -t 10 miContenedor
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Borrar, Listar, Inspeccionar
&lt;code&gt;bash
$ docker rm miContenedor
$ docker ps
$ docker ps --all
$ docker inspect miContenedor
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
* hablar de señales y su relacion con stop&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-c4f70.png&#34; width=&#34;70px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-operaciones-sobre-imagenes&#34;&gt;&amp;nbsp;Operaciones sobre imagenes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Cargar, Listar, Inspeccionar
&lt;code&gt;bash
$ docker pull repo/image:tag
$ docker load -i imagen.tar
$ docker images
$ docker inspect alpine
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Borrar, Construir, Taggear, Subir
&lt;code&gt;bash
$ docker rmi repo/image:tag
$ docker build -t image-name .
$ docker tag image-name repo/image-name:tag
$ docker push repo/image-name:tag
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
* es necesario un docker login myrepo:2376&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;ejemplo-existente&#34;&gt;Ejemplo existente&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run --name ffox -d -p 5001:5001 kaixhin/vnc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/vncffox.png&#34; width=&#34;200px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;???
Luego con un cliente vnc accedemos a un lxde con firefox instalado&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-08dc8.png&#34; width=&#34;45px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;nbsp-tecnica-para-construir-un-dockerfile&#34;&gt;&amp;nbsp;Tecnica para construir un Dockerfile&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Se inicia un shell sobre una imagen base
&lt;code&gt;bash
$ docker run -it --name testC ubuntu sh
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Se ejecutan los comandos y se van traduciendo a instrucciones de un Dockerfile&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;???
- tar
- scratch image (reserved word)
- &lt;em&gt;history&lt;/em&gt; de image
- &lt;em&gt;commit&lt;/em&gt; del container como no recomendada mas que para pruebas y debugging&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;debug&#34;&gt;Debug&lt;/h2&gt;

&lt;p&gt;a. Entramos a un contenedor corriendo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# otra alternativa, tomar una
$ docker exec -it nignxTest /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. Miramos los logs conectados&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker logs nginxTest
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;buenas-prácticas&#34;&gt;Buenas prácticas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Containers lo más prescindibles posibles&lt;/li&gt;
&lt;li&gt;Usar .dockerignore&lt;/li&gt;
&lt;li&gt;Evitar instalar paquetes innecesarios&lt;/li&gt;
&lt;li&gt;Correr un sólo proceso por container&lt;/li&gt;
&lt;li&gt;Minimizar la cantidad de capas&lt;/li&gt;
&lt;li&gt;Organizar argumentos y comandos de multiples lineas con &lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Contemplar el build cache
&lt;center&gt;
&lt;img src=&#34;http://nicosommi.github.com/assets/docker-d0772.png&#34; width=&#34;50%&#34;&gt;&lt;/img&gt;
&lt;/center&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
* prescindible = efimero = pueden ser parados, destruidos y reemplazados
* usar cache o no
* el checksum del cache, que se invalida cuando algo cambia en determinadas instrucciones, por ejemplo los archivos agregados con ADD o COPY se chequean por cada uno sin usar la fecha de modificacion, en cambio para RUN el string del comando es suficiente
* una vez invalidado, ya no se utiliza para las subsecuentes capas&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;ejemplos-docker-para-web&#34;&gt;Ejemplos docker para web&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;spa-build&#34;&gt;SPA build&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM node:6
ADD . /src
WORKDIR /src
RUN rm -fR ./node_modules &amp;amp;&amp;amp; \
  npm i
ENTRYPOINT [&amp;quot;npm&amp;quot;, &amp;quot;build&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
Hay maneras alternativas de ejecutar CMD, esa es la preferida (JSON array) ya que no tiene nada implicito (como el ´shell´ form que hace &amp;ldquo;/bin/sh -c&amp;rdquo; lo que oculta señales por ejemplo docker stop)
&amp;ndash;entrypoint overrides
* tiene que haber al menos un cmd o entrypoint
* entrypoint para ejecutables
* cmd es mas para preparar parametros&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;spa-serve&#34;&gt;SPA serve&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;version: &#39;2&#39;
services:
  spa:
    image: nginx
    volumes:
      - &amp;quot;.:/usr/share/nginx/html:ro&amp;quot;
    ports:
      - &amp;quot;10000:80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM node:6
EXPOSE 3000
ADD . /src
WORKDIR /src
RUN npm rebuild &amp;amp;&amp;amp; \
  npm test
CMD [&amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
Hay muchas alternativas, hay una tarea de diseño implícita&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;http://nicosommi.github.com/assets/docker-32d4f.png&#34; width=&#34;50px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
##&amp;nbsp; Compose&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;# docker-compose.yml just for api
version: &#39;2&#39;
services:
  api:
    image: mirepo.com/api-image:production
    ports:
      - &amp;quot;3000:3000&amp;quot;
    depends_on:
      - mongo
    environment:
      PORT: 3000
  mongo:
    image: mongo
    ports:
      - &amp;quot;27017:27017&amp;quot;
    volumes:
      - ./mongodata:/data/db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???&lt;/p&gt;

&lt;h2 id=&#34;links-puede-utilizarse-para-definir-alias-pero-no-es-necesario&#34;&gt;Links puede utilizarse para definir alias pero no es necesario&lt;/h2&gt;

&lt;h2 id=&#34;comandos-para-compose&#34;&gt;Comandos para compose&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Correr, Parar, Borrar
&lt;code&gt;bash
$ docker-compose up -d
$ docker-compose stop -t 10
$ docker-compose rm
$ docker-compose --help
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;anexo-docker-services&#34;&gt;Anexo: Docker services&lt;/h2&gt;

&lt;p&gt;Es una abstracción de los contenedores.
* Permite a un swarm de docker nodes trabajar juntos mediante la ejecucion de replica tasks, que son docker images tambien
* Se puede especificar la cantidad de replica tasks y el manager del swarm se encarga de distribuir la carga entre los nodos
* Para el cliente, el servicio luce como un docker daemon regular
* Los servicios son los que brindan escalabilidad y flexibilidad de updates
???
swarm = el plural de docker nodes&amp;hellip; manada/multitud/enjambre/nube
* temas avanzados pendientes: swarm, service discovery, pagina oficial, shipping yard, etc&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;operaciones-con-services&#34;&gt;Operaciones con services&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker service create \
  --name my-service \
  --replicas 3 \
  nginx:alpine

$ docker-compose scale service-name=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
* services global/replicated&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;q-a&#34;&gt;Q &amp;amp; A&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;gracias&#34;&gt;Gracias!&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>proxies</title>
      <link>http://nicosommi.github.com/slide/proxies/</link>
      <pubDate>Mon, 24 Oct 2016 15:38:10 -0300</pubDate>
      
      <guid>http://nicosommi.github.com/slide/proxies/</guid>
      <description>

&lt;h1 id=&#34;proxies-en-es6&#34;&gt;Proxies en ES6&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;

&lt;p&gt;&lt;small&gt;
  Terminología&lt;br /&gt;
  Desarrollo&lt;br /&gt;
  Casos de uso&lt;br /&gt;
  Ejercitación&lt;br /&gt;
  Desarrollo&lt;br /&gt;
  Casos de uso&lt;br /&gt;
  Ejercitación&lt;br /&gt;
&lt;/small&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;terminología&#34;&gt;Terminología&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;¿Que es un proxy?&lt;br /&gt;
Origen: &lt;em&gt;prokecye&lt;/em&gt;&lt;br /&gt;
  &amp;ldquo;agency of one who acts instead of another&amp;rdquo;&lt;br /&gt;
En español significa &lt;em&gt;apoderado&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;adj.&lt;/em&gt; Dicho de una persona: Que tiene poderes de otra para representarla y proceder en su nombre&lt;/p&gt;

&lt;p&gt;???
Ejemplo, firmar un poder para hacer un trámite&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;¿Que es un protocolo?&lt;br /&gt;
Un &lt;em&gt;protocolo&lt;/em&gt; es un conjunto de normas. Esto podria verse como un conjunto interfaces con reglas para usarlas, y ECMAScript define un protocolo para manejar objetos. Este protocolo opera a nivel Meta.&lt;/p&gt;

&lt;p&gt;???
La definición no es la misma que suele utilizarse de protocolos para interfaces de otros lenguajes porque también incluye reglas.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Metaprogramming&lt;/em&gt;&lt;br /&gt;
En la programación hay niveles base y meta. El nivel base procesa el input del usuario, mientras que el meta procesa al base.&lt;/p&gt;

&lt;p&gt;???
Pueden incluso ser dos lenguajes distintos.
En es como los closures, los usamos sin saber.
Hay unos que usamos constantemente: Object.*&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Meta Object Protocol&lt;/em&gt;  es como se lo llama al protocolo de manejo de objetos de ECMAScript. Como particularidad, son internos (no son accesibles desde JS). Los engines pueden usarlos o no.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Los metodos de un objeto del MOP llaman operaciones del engine, algunas que llaman a otras como [[Get]], que se llaman &lt;em&gt;operaciones derivadas&lt;/em&gt; y las que son independientes, que se llaman &lt;em&gt;operaciones fundamentales&lt;/em&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;???
Ejemplo [[Get]] usa getOwnProperty, getPrototypeOf y Call&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Tipos de metaprogramming&lt;/em&gt;&lt;br /&gt;
- Introspection: permite sólo leer la estructura
- Self-modification: permite modificar la estructura
- Intercession: redefine la semantica de algunas operaciones&lt;/p&gt;

&lt;p&gt;???
Ejemplos Object.keys, moveProperty, proxy respectivamente&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Elementos del proxy&lt;/em&gt;&lt;br /&gt;
- target: es el fallback del handler, el representado
[[ProxyTarget]]
- handler: es quien, en caso de definir el método indicado, intercepta la llamada, el representante
[[ProxyHandler]]
- proxy: el que compone ambos y delega a uno u otro&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const proxy = new Proxy(target, handler); // OK
var p = Proxy(target, handler); // TypeError: calling a builtin Proxy constructor without new is forbidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
El método del handler se llama trap.&lt;br /&gt;
Es decir que el proxy &amp;ldquo;wrappea&amp;rdquo; al target.&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;class MyHandler {
  get(target, key, receiver) {
    return Reflect[key];
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;???
Reflect no se puede instanciar, tiene los mismos metodos que el handler, es como Math, todo estatico
Por ejemplo Reflect.apply es menos verboso que Function.prototype.apply
Algunas veces nos da información adicional como Reflect.set -&amp;gt; [boolean]&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;¿Que operaciones pueden ser interceptadas?&lt;/em&gt;&lt;br /&gt;
Esto es selectivo, no se puede interceptar todo o solo las fundamentales como podria suponerse.&lt;br /&gt;
Esto es por dos razones
- porque una operacion estable corre el riesgo de que un proxy la haga inestable
- porque tener mucho codigo custom intercalado haria el programa muy dificil de entender y debuggear&lt;/p&gt;

&lt;p&gt;???
ejemplo el === que no puede ser trapeada.
Estable: sin side effects, que produce siempre el mismo resultado ante los mismos argumentos&lt;br /&gt;
Se podría pensar como que con interceptar sólo operaciones fundamentales, pero esto no es tan útil ya que no inlcuiría get por ejemplo.
Ver codigo de api client.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Prototype chain&lt;/em&gt;&lt;br /&gt;
Los engines en su comportamiento habitual, al subir por el chain, van a disparar las traps que encuentren.&lt;br /&gt;
Sin embargo, hay ciertas operaciones que suben por el prototype chain si no encuentran la property en el handler como get, set y has, las demas no alteran el prototype chain.&lt;/p&gt;

&lt;p&gt;???
Ver codigo y test de ghost.
Instanceof &amp;ldquo;lies&amp;rdquo;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Básicas&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defineProperty(target, propKey, propDesc) // → boolean  (fundamental)
  // trigger: Object.defineProperty(proxy, propKey, propDesc)
deleteProperty(target, propKey) // → boolean  (fundamental)
  // trigger: delete proxy[propKey], delete proxy.foo
get(target, propKey, receiver) // → any
  // trigger: receiver[propKey]
  // trigger: receiver.foo
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Casos de uso&lt;/em&gt;
  * API Client
  * Tracing / Logging
  * Trap undefined property access
  * Type check&lt;/p&gt;

&lt;p&gt;???
  Señalar el tracing puede implementarse cambiando el objeto.
  Type check example: properties que son &amp;ldquo;fieles&amp;rdquo; a su tipo incial.
  Ir viendo ejemplos de api client, logging y lock&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Preguntas&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Practica 1&lt;/em&gt;&lt;br /&gt;
Hacer &amp;ldquo;trap undefined&amp;rdquo;&lt;br /&gt;
&amp;ldquo;Objeto que tira excepcion cuando se accede a una propiedad undefined&amp;rdquo;
(30 minutos)&lt;/p&gt;

&lt;p&gt;???
Debe tirar un ReferenceError si no esta. Debe devolver el valor si esta.
Probar nested with lock.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Compatibilidad&lt;/em&gt;
* Solo FF, CH, Edge, Opera, Safari 10, Node 6&lt;/p&gt;

&lt;p&gt;???
No hay polyfill.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Tipos de proxy&lt;/em&gt;
* Wrappers (solo control) o Virtual Objects (agregan comporamiento)&lt;/p&gt;

&lt;p&gt;???
Wrappers se refiere a esos casos en los que intercepta para controlar el acceso al target, mientras que virtual se refiere a cuando agregan un comportamiento y el virtual object no importa (ejemplo, property check y RMI respectivamente)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Propiedades del proxy&lt;/em&gt;
* Transparencia virtual: no podemos saber si un objeto es un proxy
* Encapsulamiento: no podemos acceder al handler desde el proxy&lt;/p&gt;

&lt;p&gt;???
Wrappers se refiere a esos casos en los que intercepta para controlar el acceso al target, mientras que virtual se refiere a cuando agregan un comportamiento y el virtual object no importa (ejemplo, property check y RMI respectivamente)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Mas casos de uso&lt;/em&gt;
* DOM
* Indices negativos de array
* Data binding (polemico)
* Profiling
* RMI&lt;/p&gt;

&lt;p&gt;Note:
DOM: usualmente está implementado entre C++ y JS, y el context switch es costoso, lo que nos lleva a querer hacer el dom en js puro, pero hay cosas que no son tan simples de implementar, y ello fue una importante razon para hacer los proxies en JS (dom mas eficiente) y ademas que nos permite emular el browser (jsdom).&lt;/p&gt;

&lt;p&gt;Indices negativos como en algunos lenguajes.
Mencionar Object.observe (ES7) creado para binding por la pobre performance de los proxy, aunque abandonado por react.
Object.observe no es necesario con la inmutabilidad, tratar browser como remote rendering, no storage y query
(undo, state). Se dice que es lo que queremos, no lo que necesitamos (Stateful dom).
Profiling para medir tiempo.
RMI permite por ejemplo db access directo.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Invariants&lt;/em&gt;&lt;br /&gt;
Si el target es no extensible y no configurable, lo invariante es forzado por el engine.&lt;/p&gt;

&lt;p&gt;???
no extensible protege objetos, non configurability protege properties.
Con los proxy se podría violar la invariabilidad, pero el engine lo prohibe chequeando los parametros y los resultados de los handlers, preventExtension, true y luego false, e igual para isExtensible y getOwnPropertyDescriptor&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Practica 2&lt;/em&gt;&lt;br /&gt;
Mejorar api client&lt;br /&gt;
(30 minutos)&lt;/p&gt;

&lt;p&gt;???
elegir algunos de los TODO&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Avanzadas 1&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getOwnPropertyDescriptor(target, propKey) // → PropDesc|Undefined  (fundamental)  
  // tby: Object.getOwnPropertyDescriptor(proxy, propKey)  
getPrototypeOf(target) // → Object|Null  (fundamental)  
  // tby: Object.getPrototypeOf(proxy)  
has(target, propKey) // → boolean  
  // tby: propKey in proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Avanzadas 2&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isExtensible(target) // → boolean  (fundamental)  
  // tby: Object.isExtensible(proxy)  
ownKeys(target) // → Array&amp;lt;PropertyKey&amp;gt;  (fundamental)  
  // tby: Object.getOwnPropertyPropertyNames(proxy) (only uses string-valued keys)  
  // tby: Object.getOwnPropertyPropertySymbols(proxy) (only uses symbol-valued keys)  
  // tby: Object.keys(proxy) (only uses enumerable string-valued keys;
  // enumerability is checked via Object.getOwnPropertyDescriptor)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Avanzadas 3&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preventExtensions(target) // → boolean  (fundamental)  
  // tby: Object.preventExtensions(proxy)  
set(target, propKey, value, receiver) // → boolean  
  // tby: receiver[propKey] = value  
  // tby: receiver.foo = value // propKey = &#39;foo&#39;  
setPrototypeOf(target, proto) // → boolean  (fundamental)  
  // tby: Object.setPrototypeOf(proxy, proto)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Para funciones&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply(target, thisArgument, argumentsList) // → any  
  // tby: proxy.apply(thisArgument, argumentsList) (fundamental)  
  // tby: proxy.call(thisArgument, ...argumentsList)  
  // tby: proxy(...argumentsList)  
construct(target, argumentsList) // → Object  
  // tby: new proxy(..argumentsList)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Conclusion&lt;/em&gt;&lt;br /&gt;
* Performance
* Debug
* Casos de uso
* Complejidad
* Compatibilidad&lt;/p&gt;

&lt;p&gt;Note:
Performance: Conviene medir la performance en cada caso, evaluar que tan critica es la performance en nuestra app y tomar una decision.
A mas código interceptado, menor performance, mayor dificultad de entender el codigo y de debug.
Riesgo: podemos &amp;ldquo;romper&amp;rdquo; comportamientos, hacerlo inconsistente
Casos de uso:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Preguntas / Discusion / Ideas&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Gracias!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>