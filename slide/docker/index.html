<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--><html class="no-js" prefix="og: http://ogp.me/ns#" xmlns:og="http://ogp.me/ns#"><!--<![endif]-->

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="author" content="">
  
	
        <meta property="og:site_name" content="nicosommi">
        <meta property="og:title" content="nicosommi">
        <meta property="og:url" content="http://nicosommi.github.com/slide/docker/">
        <meta property="og:description" content="a developer&#39;s blog">
    
        <meta property="og:type" content="article" />
        <meta property="og:article:author" content="" />
        <meta property="og:article:published_time" content="2016-10-24T15:38:10-03:00" />
    
        <meta name="generator" content="Hugo 0.16" />
    <title>docker &middot; nicosommi</title>
    <link rel="canonical" href="http://nicosommi.github.com/" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="">
    <link rel="stylesheet" type="text/css" href="http://nicosommi.github.com/css/main.css"/>
    <link rel="stylesheet" type="text/css" href="http://nicosommi.github.com/css/menu.css"/>
    <link rel="stylesheet" type="text/css" href="http://nicosommi.github.com/css/slide.css"/>
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300|Montserrat:700" rel="stylesheet" type="text/css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
</head>

<body>
<!--[if lt IE 7]><p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chrome/‎">install Google Chrome</a> to experience this site.</p><![endif]-->

<head><link href="/static/css/main.94c28820.css" rel="stylesheet"></head><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div><script type="text/javascript" src="/static/js/main.32c259e6.js"></script>

<div role="main">
  
  <div class="content">
    <textarea id="source">
      &lt;!-- class: middle --&gt;
&lt;!-- layout: true --&gt;

---
&lt;img src=&#34;/assets/docker-74de8.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;

# Introduccion a docker
## Por nicosommi

---
name: agenda
## Agenda
1. Agenda y alcance
2. Fundamentos
3. Casos de uso
4. Por dentro
5. Componentes
6. Ejemplo sencillo
7. Q &amp; A
8. Mas componentes
9. Comandos sobre contenedores e imágenes
10. Ejemplo lateral
11. Técnica para construir un Dockerfile
12. Buenas prácticas
13. Docker para SPA, web apps, etc
14. Anexo: Services
15. Q &amp; A

---
class: center
## Que es?
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-89c82.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

???
Disculpen el teclado en ingles

---
* Técnicamente es una capa de abstracción para la utilización de cgroups, namespaces y UnionFS de linux.
* Basado en esto, crea el concepto de contenedor y nos permite construir de manera simple imagenes a partir de las cuales correr contenedores de manera aislada.
* UnionFS que consiste en poner una capa arriba de otra hasta lograr un sistema de archivos coherente
* Con los namespaces virtualiza los recursos como archivos, recursos de red y usuarios
* Con los cgroups aisla del uso de recursos (cpu, memoria, E/S)
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-28b55.png&#34; width=&#34;300px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

---
class: right
&lt;img style=&#34;position: absolute&#34; src=&#34;/assets/docker-04a7d.png&#34; width=&#34;200px&#34;&gt;&lt;/img&gt;
## Es una maquina virtual? No.
## Como se diferencia de una?

---

Se diferencia porque no tiene un sistema operativo host y uno guest, sino que utiliza herramientas de un sistema operativo existente para la creacion de contenedores.
&lt;center&gt;
  &lt;img src=&#34;/assets/history.png&#34; width=&#34;600px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;
???
Comentar:
* historia
* primero escalabilidad horizontal
* despues optimizar recursos
* adicionales: docker swarm independiente
Nos permite cambiar la unidad de medida de nuestra aplicación de máquinas virtuales o físicas a simples containers.

---
## En donde corre?
En sus inicios solo soportaba contenedores linux sobre linux, ahora puede correr contenedores linux-based tanto en mac como en windows y en varios otros providers (aws, etc).
Tambien, recientemente incorporaron contenedores basados en windows server.
&lt;center&gt;
  &lt;img src=&#34;/assets/platforms.png&#34; width=&#34;400px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-6a999.png&#34; width=&#34;100px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Para que sirve?
Para isolar el entorno de ejecución de una aplicación.

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/pencil.png&#34; width=&#34;80px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Datos
* Es open source desde el 2013.
* Esta escrito en go.
* Lo comenzó Solomon Hykes en dotCloud.

???
Go esta pensado para concurrencia y productividad y tiene garbage collection

---
## Casos de uso
&lt;img src=&#34;/assets/usecases.png&#34; width=&#34;90%&#34;&gt;&lt;/img&gt;
???
Invitar a sugerir ideas u opinar sobre las mencionadas
Texto:
* CI/CD
* Entornos de desarrollo
* Compilar para distintos targets
* PaaS
* Escalabilidad horizontal
* High availability cluster
* Aislar ejecucion de codigo de manera segura (webpackbin, etc)
* Aprendizaje/investigacion
* Etc...

---
## Por dentro

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-c4f70.png&#34; width=&#34;140px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Docker Image
* Es un template con instrucciones para la construccion de contenedores
* Tiene una o varias capas de solo lectura a partir del cual se crean contenedores
* Se pueden extender o empezar de cero
* Para su descripcion se utiliza una simple interfaz en un archivo de texto denominado Dockerfile
* El Dockerfile contiene instrucciones, y cada instruccion genera una capa adicional. Estas instrucciones son por ejemplo FROM, MAINTAINER, RUN, ADD, ENV, CMD.
* Docker simplemente lee las instrucciones, las ejecuta, y devuelve la imagen

---
## Docker Container
* Es una instancia de una imagen que se puede correr, parar, mover, borrar, etc.
* Contiene una fina capa adicional a las de su imagen con permisos de escritura.
* Adicionalmente puede contar con metadata, como puertos de red, variables de entorno, volumenes, etc.
* Cada contenedor es aislado pero puede tener acceso a recursos del host o de otros contenedores.
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-bb91f.png&#34; width=&#34;300px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

???
Preguntar diferencia entre contenedor e imagen y clarificar dudas

---
## Acerca del Contenedor
Previamente se utilizaba lxc, luego libcontainer, pero ahora se esta avocando a runC y a llevar adelante OCI (Open Container Initiative).
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-71f58.png&#34; width=&#34;240px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-1c5ae.png&#34; width=&#34;70px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Storage
* Utiliza union fs, que consiste en poner una capa arriba de otra hasta lograr un sistema de archivos coherente
* Es quien se encarga de manejar los archivos entre las capas de solo lectura y la del contenedor
* Docker utiliza &#39;copy on write&#39;, es decir que copia una capa sólo cuando la va a cambiar, lo que permite optimizar el tamaño en disco ocupado por la imagen y el tiempo de arranque de los contenedores.
* Toda la data de imagenes y contenedores se guarda en una carpeta.
* Hay muchas variantes de union fs (drivers): aufs, overlay/2, btrfs, zfs. Se deben elegir según caso de uso, experiencia del equipo y linux distro.

---
## Componentes
---
## Docker Engine
Aplicacion cliente/servidor. Un daemon es el servidor que levanta una API Rest la cual es utilizada por un CLI para instruirlo.
![Docker engine](/assets/docker-9cf40.png)

---
## Machine
* Manager para windows, osx y otros providers, que nos permite correr un docker host y permite manejar multiples hosts en una red desde linux.
* Nos deja instalar docker en terminales remotas y provisionar swarms.
&lt;img src=&#34;/assets/docker-7ada0.png&#34; width=&#34;95%&#34;&gt;&lt;/img&gt;
???
Permite especificar drivers para distintos providers

---
## Compose
Es una herramienta para definir y correr aplicaciones que consisten de varios containers mediante la especificacion de un archivo docker-compose.yml.
* Detecta cambios y recrea solo lo necesario
* Soporta variables en el compose file
* Guarda la data persistida en los volumes
* Es muy util para entornos de desarrollo, para deployment en un solo host
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-32d4f.png&#34; width=&#34;200px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/ubuntu.png&#34; width=&#34;50px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Ejemplo sencillo
```bash
$ docker run --name miContenedor -it ubuntu:14.04 /bin/bash
root@3883936319fb:/# lsb_release -a
(...) Description:	Ubuntu 14.04.5 LTS (...)
```
1. Trae la ultima imagen, o si ya existe la utiliza.
2. Crea, en base a la imagen, un contenedor.
3. Guarda el contenedor en una carpeta y monta una capa con permisos de escritura.
4. Asigna una interfaz de red con la cual habla con el host
5. Setea una IP de una pool
6. Ejecuta el proceso solicitado (/bin/bash)
7. Captura y devuelve el output del contenedor por haber indicado -it

???
i es para el interactive mode, que deja el stdin esperando
t asigna un pseudo tty / pty
* pull
* hablar de pull y de los otros parametros como name, port, volume

---
## Wordpress
&lt;pre&gt;
  &lt;code class=&#34;bash hljs remark-code remark-code-line&#34; style=&#34;font-size: 13px;&#34;&gt;
  version: &#39;2&#39;

  services:
     db:
       image: mysql:5.7
       volumes:
         - &#34;./.data/db:/var/lib/mysql&#34;
       restart: always
       environment: (...)

     wordpress:
       depends_on:
         - db
       image: wordpress:latest
       links:
         - db
       ports:
         - &#34;8000:80&#34;
       restart: always
       environment: (...)
  &lt;/code&gt;
&lt;/pre&gt;

???
Environment está cortado por cuestiones de espacio del slide pero es un ejemplo tomado de la página oficial

---
# Q &amp; A Parcial
---

## Docker Registry
* Es una libreria de imagenes.
* Puede ser publico o privado.
* Una vez construida la imagen, hacemos un push al registry
* Docker hub es un registry publico oficial
* Hay una imagen publica registry y una para el trusted registry
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-89504.png&#34; width=&#34;240px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;
???
Trusted registry es con soporte comercial

---
## Data volumes
* Encontrar
```bash
$ docker inspect myContainer
```
* Se pueden crear volúmenes o montar desde el host
```bash
$ docker run -d -P --name web -v /webapp myImage npm start
$ docker run -d -P --name web -v /src:/webapp myImage npm start
```
???
* bypass a unionfs
* si no esta bindeado a host, copia el contenido adentro
* permite compartir entre containers con compose o con named volumes (flocker por ejemplo)
* esta diseñado para cambiar el container y que la data persista, incluso aunque ningun container la referencie
* soporta SCSI, NFS, etc.

---
## Data volume containers
* *[Es una práctica](/index.php/2016/09/06/contenedores-unicamente-de-volumenes-en-docker-volume-only-containers/)* que consiste en crear un contenedor que sólo contiene data que luego será utilizada por otros contenedores
```bash
$ docker create -v /dbdata --name mydb postgres /bin/true
$ docker run -d --volumes-from mydb --name db1 postgres
```

---
## Network
* Puede ser bridge, none  y host
```bash
$ docker network ls
```
* Pueden verse los detalles
```bash
$ docker network inspect bridge
```
* Se pueden crear nuestras redes en las cuales correr containers
???
* un container puede pertenecer a varias redes
* se ven entre los de la misma red
* puede ser overlay (swarm mode) o custom driver
* embedded dns en custom networks
* antes habia links y ahora se solapa un poco con networks, comparte envs, escribe el hosts

---
## Docker Aplicado

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-28b55.png&#34; width=&#34;70px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Operaciones sobre contenedores
* Run, Start, Stop
```bash
# crea un contenedor en base a una imagen y corre el comando bash
$ docker run --name miContenedor alpine echo &#34;Hola&#34;
# arrancar un contenedor ya creado
$ docker start miContenedor
# parar contenedor con time to kill
$ docker stop -t 10 miContenedor
# also valid: docker restart -t 10 miContenedor
```

---
* Borrar, Listar, Inspeccionar
```bash
$ docker rm miContenedor
$ docker ps
$ docker ps --all
$ docker inspect miContenedor
```

???
* hablar de señales y su relacion con stop

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-c4f70.png&#34; width=&#34;70px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Operaciones sobre imagenes
* Cargar, Listar, Inspeccionar
```bash
$ docker pull repo/image:tag
$ docker load -i imagen.tar
$ docker images
$ docker inspect alpine
```

---
* Borrar, Construir, Taggear, Subir
```bash
$ docker rmi repo/image:tag
$ docker build -t image-name .
$ docker tag image-name repo/image-name:tag
$ docker push repo/image-name:tag
```

???
* es necesario un docker login myrepo:2376

---
## Ejemplo existente
```bash
$ docker run --name ffox -d -p 5001:5001 kaixhin/vnc
```
&lt;center&gt;
  &lt;img src=&#34;/assets/vncffox.png&#34; width=&#34;200px&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

???
Luego con un cliente vnc accedemos a un lxde con firefox instalado

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-08dc8.png&#34; width=&#34;45px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
## &amp;nbsp;Tecnica para construir un Dockerfile
1. Se inicia un shell sobre una imagen base
```bash
$ docker run -it --name testC ubuntu sh
```
2. Se ejecutan los comandos y se van traduciendo a instrucciones de un Dockerfile

???
- tar
- scratch image (reserved word)
- *history* de image
- *commit* del container como no recomendada mas que para pruebas y debugging

---
## Debug
a. Entramos a un contenedor corriendo
```bash
# otra alternativa, tomar una
$ docker exec -it nignxTest /bin/bash
```
b. Miramos los logs conectados
```bash
docker logs nginxTest
```

---
## Buenas prácticas
* Containers lo más prescindibles posibles
* Usar .dockerignore
* Evitar instalar paquetes innecesarios
* Correr un sólo proceso por container
* Minimizar la cantidad de capas
* Organizar argumentos y comandos de multiples lineas con \
* Contemplar el build cache
&lt;center&gt;
  &lt;img src=&#34;/assets/docker-d0772.png&#34; width=&#34;50%&#34;&gt;&lt;/img&gt;
&lt;/center&gt;

???
* prescindible = efimero = pueden ser parados, destruidos y reemplazados
* usar cache o no
* el checksum del cache, que se invalida cuando algo cambia en determinadas instrucciones, por ejemplo los archivos agregados con ADD o COPY se chequean por cada uno sin usar la fecha de modificacion, en cambio para RUN el string del comando es suficiente
* una vez invalidado, ya no se utiliza para las subsecuentes capas

---
## Ejemplos docker para web

---
## SPA build
```Dockerfile
FROM node:6
ADD . /src
WORKDIR /src
RUN rm -fR ./node_modules &amp;&amp; \
  npm i
ENTRYPOINT [&#34;npm&#34;, &#34;build&#34;]
```
???
Hay maneras alternativas de ejecutar CMD, esa es la preferida (JSON array) ya que no tiene nada implicito (como el ´shell´ form que hace &#34;/bin/sh -c&#34; lo que oculta señales por ejemplo docker stop)
--entrypoint overrides
* tiene que haber al menos un cmd o entrypoint
* entrypoint para ejecutables
* cmd es mas para preparar parametros

---
## SPA serve
```Dockerfile
version: &#39;2&#39;
services:
  spa:
    image: nginx
    volumes:
      - &#34;.:/usr/share/nginx/html:ro&#34;
    ports:
      - &#34;10000:80&#34;
```
---
## API
```Dockerfile
FROM node:6
EXPOSE 3000
ADD . /src
WORKDIR /src
RUN npm rebuild &amp;&amp; \
  npm test
CMD [&#34;npm&#34;, &#34;start&#34;]
```
???
Hay muchas alternativas, hay una tarea de diseño implícita

---
&lt;div style=&#34;float: left;&#34;&gt;
  &lt;img src=&#34;/assets/docker-32d4f.png&#34; width=&#34;50px&#34;&gt;&lt;/img&gt;
&lt;/div&gt;
##&amp;nbsp; Compose
```Dockerfile
# docker-compose.yml just for api
version: &#39;2&#39;
services:
  api:
    image: mirepo.com/api-image:production
    ports:
      - &#34;3000:3000&#34;
    depends_on:
      - mongo
    environment:
      PORT: 3000
  mongo:
    image: mongo
    ports:
      - &#34;27017:27017&#34;
    volumes:
      - ./mongodata:/data/db
```

???
Links puede utilizarse para definir alias pero no es necesario
---
## Comandos para compose
* Correr, Parar, Borrar
```bash
$ docker-compose up -d
$ docker-compose stop -t 10
$ docker-compose rm
$ docker-compose --help
```

---
## Anexo: Docker services
Es una abstracción de los contenedores.
* Permite a un swarm de docker nodes trabajar juntos mediante la ejecucion de replica tasks, que son docker images tambien
* Se puede especificar la cantidad de replica tasks y el manager del swarm se encarga de distribuir la carga entre los nodos
* Para el cliente, el servicio luce como un docker daemon regular
* Los servicios son los que brindan escalabilidad y flexibilidad de updates
???
swarm = el plural de docker nodes... manada/multitud/enjambre/nube
* temas avanzados pendientes: swarm, service discovery, pagina oficial, shipping yard, etc

---
## Operaciones con services
```bash
$ docker service create \
  --name my-service \
  --replicas 3 \
  nginx:alpine

$ docker-compose scale service-name=2
```
???
* services global/replicated

---
# Q &amp; A
---

# Gracias!

    </textarea>
  </div>
</div>

<script>
    var slideshow = remark.create();
</script>

    <script>
        var _gaq=[['_setAccount','UA-44929876-1'],['_trackPageview']];
        (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
        g.src='//www.google-analytics.com/ga.js';
        s.parentNode.insertBefore(g,s)}(document,'script'));
    </script>

</body>
</html>
