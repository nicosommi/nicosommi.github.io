<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--><html class="no-js" prefix="og: http://ogp.me/ns#" xmlns:og="http://ogp.me/ns#"><!--<![endif]-->

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="author" content="">
  
	
        <meta property="og:site_name" content="nicosommi">
        <meta property="og:title" content="nicosommi">
        <meta property="og:url" content="http://nicosommi.github.com/slide/proxies/">
        <meta property="og:description" content="a developer&#39;s blog">
    
        <meta property="og:type" content="article" />
        <meta property="og:article:author" content="" />
        <meta property="og:article:published_time" content="2016-10-24T15:38:10-03:00" />
    
        <meta name="generator" content="Hugo 0.16" />
    <title>proxies &middot; nicosommi</title>
    <link rel="canonical" href="http://nicosommi.github.com/" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="">
    <link rel="stylesheet" type="text/css" href="http://nicosommi.github.com/css/main.css"/>
    <link rel="stylesheet" type="text/css" href="http://nicosommi.github.com/css/menu.css"/>
    <link rel="stylesheet" type="text/css" href="http://nicosommi.github.com/css/slide.css"/>
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300|Montserrat:700" rel="stylesheet" type="text/css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
</head>

<body>
<!--[if lt IE 7]><p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chrome/‎">install Google Chrome</a> to experience this site.</p><![endif]-->

<head><link href="/static/css/main.94c28820.css" rel="stylesheet"></head><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div><script type="text/javascript" src="/static/js/main.32c259e6.js"></script>

<div role="main">
  
  <div class="content">
    <textarea id="source">
      # Proxies en ES6

---

## Agenda
&lt;small&gt;
  Terminología  
  Desarrollo  
  Casos de uso  
  Ejercitación  
  Desarrollo  
  Casos de uso  
  Ejercitación  
&lt;/small&gt;

---

## Terminología

---

¿Que es un proxy?  
Origen: *prokecye*  
  &#34;agency of one who acts instead of another&#34;  
En español significa *apoderado*  
  *adj.* Dicho de una persona: Que tiene poderes de otra para representarla y proceder en su nombre

???
Ejemplo, firmar un poder para hacer un trámite

---

¿Que es un protocolo?  
Un *protocolo* es un conjunto de normas. Esto podria verse como un conjunto interfaces con reglas para usarlas, y ECMAScript define un protocolo para manejar objetos. Este protocolo opera a nivel Meta.

???
La definición no es la misma que suele utilizarse de protocolos para interfaces de otros lenguajes porque también incluye reglas.

---

*Metaprogramming*  
En la programación hay niveles base y meta. El nivel base procesa el input del usuario, mientras que el meta procesa al base.  

???
Pueden incluso ser dos lenguajes distintos.
En es como los closures, los usamos sin saber.
Hay unos que usamos constantemente: Object.*

---

*Meta Object Protocol*  es como se lo llama al protocolo de manejo de objetos de ECMAScript. Como particularidad, son internos (no son accesibles desde JS). Los engines pueden usarlos o no.

---

- Los metodos de un objeto del MOP llaman operaciones del engine, algunas que llaman a otras como [[Get]], que se llaman *operaciones derivadas* y las que son independientes, que se llaman *operaciones fundamentales*.  

???
Ejemplo [[Get]] usa getOwnProperty, getPrototypeOf y Call

---

*Tipos de metaprogramming*  
- Introspection: permite sólo leer la estructura
- Self-modification: permite modificar la estructura
- Intercession: redefine la semantica de algunas operaciones

???
Ejemplos Object.keys, moveProperty, proxy respectivamente

---

*Elementos del proxy*  
- target: es el fallback del handler, el representado
[[ProxyTarget]]
- handler: es quien, en caso de definir el método indicado, intercepta la llamada, el representante
[[ProxyHandler]]
- proxy: el que compone ambos y delega a uno u otro

```
const proxy = new Proxy(target, handler); // OK
var p = Proxy(target, handler); // TypeError: calling a builtin Proxy constructor without new is forbidden
```

???
El método del handler se llama trap.  
Es decir que el proxy &#34;wrappea&#34; al target.

---

```
class MyHandler {
  get(target, key, receiver) {
    return Reflect[key];
  }
}
```

???
Reflect no se puede instanciar, tiene los mismos metodos que el handler, es como Math, todo estatico
Por ejemplo Reflect.apply es menos verboso que Function.prototype.apply
Algunas veces nos da información adicional como Reflect.set -&gt; [boolean]

---

*¿Que operaciones pueden ser interceptadas?*  
Esto es selectivo, no se puede interceptar todo o solo las fundamentales como podria suponerse.  
Esto es por dos razones
- porque una operacion estable corre el riesgo de que un proxy la haga inestable
- porque tener mucho codigo custom intercalado haria el programa muy dificil de entender y debuggear

???
ejemplo el === que no puede ser trapeada.
Estable: sin side effects, que produce siempre el mismo resultado ante los mismos argumentos  
Se podría pensar como que con interceptar sólo operaciones fundamentales, pero esto no es tan útil ya que no inlcuiría get por ejemplo.
Ver codigo de api client.

---

*Prototype chain*  
Los engines en su comportamiento habitual, al subir por el chain, van a disparar las traps que encuentren.  
Sin embargo, hay ciertas operaciones que suben por el prototype chain si no encuentran la property en el handler como get, set y has, las demas no alteran el prototype chain.

???
Ver codigo y test de ghost.
Instanceof &#34;lies&#34;

---

*Básicas*
```
defineProperty(target, propKey, propDesc) // → boolean  (fundamental)
  // trigger: Object.defineProperty(proxy, propKey, propDesc)
deleteProperty(target, propKey) // → boolean  (fundamental)
  // trigger: delete proxy[propKey], delete proxy.foo
get(target, propKey, receiver) // → any
  // trigger: receiver[propKey]
  // trigger: receiver.foo
```

---

  *Casos de uso*
  * API Client
  * Tracing / Logging
  * Trap undefined property access
  * Type check

  ???
  Señalar el tracing puede implementarse cambiando el objeto.
  Type check example: properties que son &#34;fieles&#34; a su tipo incial.
  Ir viendo ejemplos de api client, logging y lock

---

*Preguntas*

---

*Practica 1*  
Hacer &#34;trap undefined&#34;  
&#34;Objeto que tira excepcion cuando se accede a una propiedad undefined&#34;
(30 minutos)

???
Debe tirar un ReferenceError si no esta. Debe devolver el valor si esta.
Probar nested with lock.

---

*Compatibilidad*
* Solo FF, CH, Edge, Opera, Safari 10, Node 6

???
No hay polyfill.

---

*Tipos de proxy*
* Wrappers (solo control) o Virtual Objects (agregan comporamiento)

???
Wrappers se refiere a esos casos en los que intercepta para controlar el acceso al target, mientras que virtual se refiere a cuando agregan un comportamiento y el virtual object no importa (ejemplo, property check y RMI respectivamente)

---

*Propiedades del proxy*
* Transparencia virtual: no podemos saber si un objeto es un proxy
* Encapsulamiento: no podemos acceder al handler desde el proxy

???
Wrappers se refiere a esos casos en los que intercepta para controlar el acceso al target, mientras que virtual se refiere a cuando agregan un comportamiento y el virtual object no importa (ejemplo, property check y RMI respectivamente)

---

*Mas casos de uso*
* DOM
* Indices negativos de array
* Data binding (polemico)
* Profiling
* RMI

Note:
DOM: usualmente está implementado entre C&#43;&#43; y JS, y el context switch es costoso, lo que nos lleva a querer hacer el dom en js puro, pero hay cosas que no son tan simples de implementar, y ello fue una importante razon para hacer los proxies en JS (dom mas eficiente) y ademas que nos permite emular el browser (jsdom).

Indices negativos como en algunos lenguajes.
Mencionar Object.observe (ES7) creado para binding por la pobre performance de los proxy, aunque abandonado por react.
Object.observe no es necesario con la inmutabilidad, tratar browser como remote rendering, no storage y query
(undo, state). Se dice que es lo que queremos, no lo que necesitamos (Stateful dom).
Profiling para medir tiempo.
RMI permite por ejemplo db access directo.

---

*Invariants*  
Si el target es no extensible y no configurable, lo invariante es forzado por el engine.

???
no extensible protege objetos, non configurability protege properties.
Con los proxy se podría violar la invariabilidad, pero el engine lo prohibe chequeando los parametros y los resultados de los handlers, preventExtension, true y luego false, e igual para isExtensible y getOwnPropertyDescriptor

---

*Practica 2*  
Mejorar api client  
(30 minutos)

???
elegir algunos de los TODO

---

*Avanzadas 1*  
```
getOwnPropertyDescriptor(target, propKey) // → PropDesc|Undefined  (fundamental)  
  // tby: Object.getOwnPropertyDescriptor(proxy, propKey)  
getPrototypeOf(target) // → Object|Null  (fundamental)  
  // tby: Object.getPrototypeOf(proxy)  
has(target, propKey) // → boolean  
  // tby: propKey in proxy
```

---

*Avanzadas 2*  
```
isExtensible(target) // → boolean  (fundamental)  
  // tby: Object.isExtensible(proxy)  
ownKeys(target) // → Array&lt;PropertyKey&gt;  (fundamental)  
  // tby: Object.getOwnPropertyPropertyNames(proxy) (only uses string-valued keys)  
  // tby: Object.getOwnPropertyPropertySymbols(proxy) (only uses symbol-valued keys)  
  // tby: Object.keys(proxy) (only uses enumerable string-valued keys;
  // enumerability is checked via Object.getOwnPropertyDescriptor)
```

---

*Avanzadas 3*  
```
preventExtensions(target) // → boolean  (fundamental)  
  // tby: Object.preventExtensions(proxy)  
set(target, propKey, value, receiver) // → boolean  
  // tby: receiver[propKey] = value  
  // tby: receiver.foo = value // propKey = &#39;foo&#39;  
setPrototypeOf(target, proto) // → boolean  (fundamental)  
  // tby: Object.setPrototypeOf(proxy, proto)
```

---

*Para funciones*  
```
apply(target, thisArgument, argumentsList) // → any  
  // tby: proxy.apply(thisArgument, argumentsList) (fundamental)  
  // tby: proxy.call(thisArgument, ...argumentsList)  
  // tby: proxy(...argumentsList)  
construct(target, argumentsList) // → Object  
  // tby: new proxy(..argumentsList)
```

---

*Conclusion*  
* Performance
* Debug
* Casos de uso
* Complejidad
* Compatibilidad

Note:
Performance: Conviene medir la performance en cada caso, evaluar que tan critica es la performance en nuestra app y tomar una decision.
A mas código interceptado, menor performance, mayor dificultad de entender el codigo y de debug.
Riesgo: podemos &#34;romper&#34; comportamientos, hacerlo inconsistente
Casos de uso:

---

*Preguntas / Discusion / Ideas*

---

Gracias!

    </textarea>
  </div>
</div>

<script>
    var slideshow = remark.create();
</script>

    <script>
        var _gaq=[['_setAccount','UA-44929876-1'],['_trackPageview']];
        (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
        g.src='//www.google-analytics.com/ga.js';
        s.parentNode.insertBefore(g,s)}(document,'script'));
    </script>

</body>
</html>
